[{"title":"JavaScript忍者秘籍（一）","url":"/ebaa4fc9c186/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%B8%80%EF%BC%89/","content":"web应用运行时的构建过程生命周期\n从用户在浏览器地址栏输入URL或者点击链接开始，浏览器向服务器请求了由HTML、CSS、JavaScript组成的资源。当浏览器接收到这些资源，我们的web应用正式开启它的生命周期。\n\n\n执行步骤如下：\n\n页面构建——浏览器解析HTML，构建DOM树；解析CSS，构建CSSOM树，解析JavaScript，执行代码。\n事件处理——浏览器等待用户交互并在事件发生时执行事件处理程序。\n\n当用户离开或关闭页面时，该web应用的生命周期结束。\n页面构建当web应用被请求完成但可以被展示或交互之前，浏览器需要根据服务器响应的HTML、CSS和JavaScript完成对页面的构建：\n\n解析HTML，构建DOM树\n执行JavaScript——在浏览器解析HTML的过程中，如果遇到JavaScript脚本标签（&lt;script&gt;），浏览器会停止构建DOM树，执行该段代码；随后继续构建DOM树。\n\n事件处理概览由于浏览器的事件处理机制为单线程执行模型，为实现它，浏览器使用了任务队列机制，所有已生成的事件（无论是用户生成的，例如鼠标移动或键盘点击，还是服务器生成的，例如Ajax事件）都会放在同一个事件队列中，以它们被浏览器检测到的顺序排列。\n\n浏览器检查事件队列头；\n如果浏览器没有在队列中检测到事件，则继续检查；\n如果浏览器在队列头中检测到了事件，则取出该事件并执行相应的事件处理器（如果存在）。在这个过程中，余下的事件在事件队列中耐心等待，直到轮到它们被处理\n\n\n事件可能会以难以预计的时间和顺序发生，我们对事件的处理，以及处理函数的调用是异步的。如下类型的事件会在其他类型事件中发生：\n\n浏览器事件，例如当页面加载完成后或无法加载时；\n网络事件，例如来自服务器的响应（Ajax事件和服务器端事件）；\n用户事件，例如鼠标单击、鼠标移动和键盘事件；\n计时器事件，当timeout时间到期或又触发了一次时间间隔。\n\n注册事件处理器在JavaScript中，我们可以通过两种方式注册事件处理器：\n\n将事件处理函数赋给特定属性\n调用addEventListener()方法\n\n处理事件事件处理背后的主要思想是：当事件发生时，浏览器调用相应的事件处理器。由于单线程执行模型，所以浏览器同一时刻只能处理一个事件，且处理顺序是事件生成的顺序。任何后面的事件都只能在当前事件处理器完全结束执行后才能被处理！\n","categories":["前端","javascript"],"tags":["前端","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript忍者秘籍（二）","url":"/de0931cb981b/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"闭包和作用域\n闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。\n\n使用闭包1. 封装私有变量function n()&#123;  let count = 0;  this.getCount = function()&#123;    return count;  &#125;  this.countPlus = function()&#123;    count++;  &#125;&#125;const n1 = new n();n1.countPlus();console.log(n1.count); // undefined 无法直接访问到count变量console.log(n1.getCount()); // 1 通过闭包访问到count变量const n2 = new n();console.log(n2.getCount()); // 0 n1和n2是两个独立的实例，互不影响\n\n在构造器 n 中，我们定义了一个 count 变量来保存状态，由于 count 变量是在构造器内部定义的，因此外部无法直接访问到它。但是通过闭包的方式，我们可以通过 getCount() 和 countPlus() 方法来间接地操作这个私有变量。而像 getCount() 这中只读访问的方法被称为 getter 方法，而像 countPlus() 这样仅修改私有变量的方法被称为 setter 方法。\n2. 回调函数\n回调函数指的是需要在将来不确定的某一时刻异步调用的函数。通常，在这种回调函数中，我们经常需要频繁地访问外部数据。\n\n&lt;div id=&quot;box1&quot;&gt;First Box&lt;/div&gt;&lt;script&gt;  function animate(element)&#123;    const el = document.getElementById(element);    let tick = 0;    let timer = setInterval(function()&#123;      if(tick &lt; 100)&#123;        el.style.left = el.style.top = `$&#123;tick&#125;px`;        tick++;      &#125; else &#123;        clearInterval(timer);      &#125;    &#125;, 10)  &#125;  animate(&#x27;box1&#x27;);&lt;/script&gt;\n\n\n\n  \n    First Box\n    \n      function animate(element){\n        const el = document.getElementById(element);\n        let tick = 0;\n        let timer = setInterval(function(){\n          if(tick < 100){\n            el.style.marginLeft = `${tick}px`;\n            tick++;\n          } else {\n            clearInterval(timer);\n          }\n        }, 10)\n      }\n      animate('box1')\n    \n  \n\n\n\n\n闭包内的函数不仅可以在创建的时刻访问这些变量，而且当闭包内部的函数执行时，还可以更新这些变量的值。闭包不是在创建的那一时刻的状态的快照，而是一个真实的状态封装，只要闭包存在，就可以对变量进行修改。\n\njs的变量类型在词法环境中注册标识符const first = &#x27;first&#x27;;check(first)function check(val)&#123;  console.log(val);&#125;\n由以上代码可以看出：JavaScript对于在哪儿定义函数并不挑剔。在调用函数之前或之后声明函数均可。\n注册标识符的过程\n\n如果是创建一个函数环境，那么创建形参及函数参数的默认值。如果是非函数环境，将跳过此步骤。\n如果是创建全局或函数环境，就扫描当前代码进行函数声明（不会扫描其他函数的函数体），但是不会扫描函数表达式或箭头函数。对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上。若该标识符已经存在，那么该标识符的值将被重写。如果是块级作用域，将跳过此步骤。\n扫描当前代码，查找其中的变量声明。先去查找当前函数以及其他函数之外定义的 var 变量，再去寻找所有在其他函数或代码块之外定义的 let 和 const 变量。在块级环境中仅查找当前块中定义的 let 和 const 变量。对于找到的每个变量声明，在当前环境中创建该变量的标识符，并将其初始化为 undefined，若标识符已存在则保留原有值。\n\ngraph TD;\n   A&#123;当前是否为函数环境？&#125;\n   A --&gt; |是|B(创建函数的参数对象arguments和形参)\n   A --&gt; |否|C&#123;当前环境是全局环境或函数环境？&#125;\n   B --&gt; C\n   C --&gt; |是|D(注册其他函数外的函数声明)\n   C --&gt; |否|E&#123;当前环境是否为块级作用域&#125;\n   D --&gt; E\n   E --&gt; |是|F(注册当前块内的let和const变量)\n   E --&gt; |否|G(注册函数作用域之外的var变量以及在其他函数或代码块之外定义的let和const变量)\n\n闭包的工作原理私有变量现在我们使用前文的例子再次模拟私有变量。\nfunction n()&#123;  let count = 0;  this.getCount = function()&#123;    return count;  &#125;  this.countPlus = function()&#123;    count++;  &#125;&#125;const n1 = new n();n1.countPlus();console.log(n1.count); // undefined 无法直接访问到count变量console.log(n1.getCount()); // 1 通过闭包访问到count变量const n2 = new n();console.log(n2.getCount()); // 0 n1和n2是两个独立的实例，互不影响\n\njavaScript引擎在通过 new 关键字创建 n 函数时，会创建一个新的词法环境，每个词法环境都会包含一份构造函数 n 的局部变量。由于我们在 n 函数中定义了 getCount 和 countPlus 函数，所以这些函数均包含 n 函数的词法环境。\n因为 getCount 和 countPlus 函数是在 n 中新创建的方法（可以通过this关键字访问）。所以可以在 n 函数的外部访问到这些函数，此时就创建了一个包含 count 变量的闭包。\n回调函数这次我们改造前文回调函数\n&lt;div id=&quot;box1&quot;&gt;First Box&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt;second Box&lt;/div&gt;&lt;script&gt;  function animate(element)&#123;    const el = document.getElementById(element);    let tick = 0;    let timer = setInterval(function()&#123;      if(tick &lt; 100)&#123;        el.style.left = el.style.top = `$&#123;tick&#125;px`;        tick++;      &#125; else &#123;        clearInterval(timer);      &#125;    &#125;, 10)  &#125;  animate(&#x27;box1&#x27;);  animate(&#x27;box2&#x27;);&lt;/script&gt;\n在每次调用 animate 函数时，都会创建一个新的词法环境，该词法环境包含了动画所需的变量。只要有一个通过闭包访问这些变量的函数存在，那么这些变量就不会被销毁。即在以上代码中，setInterval 的回调函数会一直存在，直到调用 clearInterval 方法。\n总结\n通过闭包可以访问闭包创建时所处词法环境中的所有变量，通过这种方式，即使创建函数时所处的作用域已经消失，我们仍然可以访问到这些变量。\n可以通过闭包来实现以下功能：\n通过构造函数内的变量以及构造方法来模拟私有变量\n处理回调函数，简化代码\n\n\n闭包是JavaScript作用域规则的副作用。当函数创建时所在的作用域消失后，仍然能够调用函数。\nJavaScript引擎通过词法环境跟踪标识符（俗称作用域）。\nJavaScript引擎通过执行上下文栈（调用栈）跟踪函数的执行。每次调用函数时，都会创建新的函数执行上下文，并推入调用栈顶端。当函数执行完成后，对应的执行上下文将从调用栈中推出（在js代码执行时默认会创建一个全局的执行上下文）。\n\n","categories":["前端","javascript"],"tags":["前端","javascript","JavaScript忍者秘籍"]},{"title":"css世界-记录","url":"/741b471ab1bd/css%E4%B8%96%E7%95%8C-%E8%AE%B0%E5%BD%95/","content":"任意高度元素的展开收起动画使用 max-height 配合 transition 实现 ，当 max-height 比设定的 height 大的时候，元素的高度取 height 的值。\n.el &#123;  max-height: 0;  overflow: hidden;  transition: max-height 0.25s;&#125;.el.active &#123;  max-height: 1000px;&#125;\n\n需要注意，虽然 max-height 需要大于 height，但是需要 max-height 的值不能过大，这样会导致过渡动画可能不明显，比如，当前的元素高度是 100 像素，而 max-height 是 1000 像素，动画时间是 250ms，假设动画函数是线性的，则前 225ms 是看不到收起效果的，因为 max-height 从 1000 像素 到 100 像素 变化这段时间，元素不会有区域被隐藏，会给人动画延迟 225ms 的感觉。 所以需要给 max-height 设定一个足够安全（使动画按照预期发生）的值。\n幽灵空白节点在 HTML5 中，内联元素渲染后在页面的表现如同该元素盒子前有一个“空白节点”一样，这个“空白节点”是透明的、不占据宽度且无法通过代码获取，其表现如同文本节点。（非 HTML5 的内联元素不存在该现象）\n规范中实际上对这个“幽灵空白节点”是有提及的，“幽灵空白节点” 实际上也是一个盒子，不过是个假想盒，名叫“strut”，中文直译为“支柱”，是一个存在于每个“行框盒子”前面，同时具有该元素的字体和行高属性的0宽度的内联盒\n层叠上下文准则\n谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index 属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个\n后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素\n\n","categories":["前端","CSS"],"tags":["前端","CSS"]},{"title":"hexo配置aPlayer播放器","url":"/f95cfd58c53a/hexo%E9%85%8D%E7%BD%AEaplayer%E6%92%AD%E6%94%BE%E5%99%A8/","content":"首先安装 hexo-tag-aplayer 插件 npm install hexo-tag-aplayer --save\n然后在主题配置文件 _config.**.yml 文件中添加配置\naplayer:  asset_inject: true  # 自动插入 Aplayer.js 与 Meting.js 资源脚本, 默认开启  meting: true # 启用 metingjs\n之后根据官方文档进行配置即可 hexo-tag-aplayer\n这里主要介绍配置aPlayer全局播放的配置方式\n首先设置 asset_inject 为 false，之后在主题的配置文件中使用 inject 注入aPlayer的dom结构，由于需要全局播放所以需要开启 pjax 功能。注意 pjax 和 aplayer 配置项在同一个配置文件中最好。\naplayer:  asset_inject: false  meting: truepjax:  enable: trueinject:  bottom:    # 注入音乐播放器    - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;&quot; data-server=&quot;&quot; data-type=&quot;&quot; data-fixed=&quot;&quot; data-autoplay=&quot;&quot;&gt; &lt;/div&gt;\naplayer使用的参数如下：\n\n\n\n选项\n默认值\n描述\n\n\n\ndata-id\n必填\n音乐id、播放列表id、相册id、搜索关键字\n\n\nserver\n必填\n音乐数据源：netease（网易云）、tencent（QQ音乐）、kugou、xiaomi、baidu\n\n\ntype\n必填\nsong（音乐）、playlist（播放列表，歌单）、album、search（关键词搜索）\n\n\nfixed\nfalse\n是否开启固定模式\n\n\nmini\nfalse\n是否开启迷你模式\n\n\nloop\nall\n列表循环模式：all,one,none\n\n\norder\nlist\n列表播放模式：list,random\n\n\nautoplay\ntrue\n是否自动播放,根据浏览器规则可能不可用\n\n\nvolume\n0.7\n初始音量，范围为0到1\n\n\npreload\nauto\n预加载模式：none,metadata,auto\n\n\ntheme\n#ad7a86\n主题颜色，支持16进制颜色代码\n\n\nlistmaxheight\n340px\n播放列表最大高度，单位为px\n\n\nmutex\ntrue\n互斥模式，开启后同一时间只能播放一个播放器实例\n\n\nlistfolded\nfalse\n列表折叠状态，默认不折叠\n\n\naPlayer 官方文档：APlayer\n","categories":["hexo"],"tags":["hexo","aPlayer"]},{"title":"css计数器","url":"/1b3605bb078e/css%E8%AE%A1%E6%95%B0%E5%99%A8/","content":"CSS 可以通过其计数器功能实现不使用 js 在列表前添加序号等操作。\n1. 初始化计数器counter-reset: name number;\n\n\nname: 设定的计数器名称\nnumber：计数器初始值，默认为 0\n\n2. 操作值counter-increment: name number;\n\n\nname: 计数器名称\nnumber: 增加的值，默认为 1，可以设置为 0 和负数\n\n3.获取并显示值content: counter(name, style);\n\n\nname: 计数器名称\nstyle: 计数器样式，见 counter-style_计数器样式\n\n也可使用 counters\ncounters(name, string, style)\n\n\nname: 计数器名称\nstring: 用来定义多个计数器同时使用的连接符\nstyle: 计数器样式，\n\n例 1（使用 counter）&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;style&gt;      body &#123;        counter-reset: section;      &#125;      h2::before &#123;        counter-increment: section;        content: &quot;Section &quot; counter(section) &quot;: &quot;;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h2&gt;标题1&lt;/h2&gt;    &lt;h2&gt;标题2&lt;/h2&gt;    &lt;h2&gt;标题3&lt;/h2&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n\n效果如下\n\n\n\n  \n    \n    \n      body {\n        counter-reset: section;   \n      }\n      h2::before {\n        counter-increment: section;\n        content: \"Section \" counter(section) \": \";\n      }\n    \n  \n  \n    标题1\n    标题2\n    标题3\n  \n\n\n\n例 2（使用 counters）&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;style&gt;      ol &#123;        counter-reset: section;        list-style-type: none;      &#125;      li::before &#123;        counter-increment: section;        content: counters(section, &quot;.&quot;) &quot; &quot;;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;ol&gt;      &lt;li&gt;item&lt;/li&gt;      &lt;li&gt;        item        &lt;ol&gt;          &lt;li&gt;item&lt;/li&gt;          &lt;li&gt;item&lt;/li&gt;          &lt;li&gt;            item            &lt;ol&gt;              &lt;li&gt;item&lt;/li&gt;              &lt;li&gt;item&lt;/li&gt;              &lt;li&gt;item&lt;/li&gt;            &lt;/ol&gt;          &lt;/li&gt;          &lt;li&gt;item&lt;/li&gt;        &lt;/ol&gt;      &lt;/li&gt;      &lt;li&gt;item&lt;/li&gt;      &lt;li&gt;item&lt;/li&gt;    &lt;/ol&gt;    &lt;ol&gt;      &lt;li&gt;item&lt;/li&gt;      &lt;li&gt;item&lt;/li&gt;    &lt;/ol&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n效果如下\n\n\n\n  \n    \n    \n      ol {\n        counter-reset: s2;\n        list-style-type: none;\n      }\n      li::before {\n        counter-increment: s2;\n        content: counters(s2, \".\") \" \";\n      }\n    \n  \n  \n    \n      item\n      \n        item\n        \n          item\n          item\n          \n            item\n            \n              item\n              item\n              item\n            \n          \n          item\n        \n      \n      item\n      item\n    \n    \n      item\n      item\n    \n  \n\n\n\n","categories":["前端","CSS"],"tags":["前端","CSS"]},{"title":"微信小程序构建npm","url":"/cbcd0deeb7dd/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%84%E5%BB%BAnpm/","content":"在微信小程序中初始化 npm从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。\n初始化 npm\n在小程序项目根目录下执行 npm init 命令，生成 package.json 文件。\n\n在 package.json 中添加依赖包：\nnpm install --save &lt;package-name&gt;@&lt;version&gt;\n\n\n如果仅需要初始化而暂时不安装依赖，可以在 package.json 目录下创建一个空的 node_modules 目录。\n\n\n安装依赖后设置project.config.json：\n&#123;  &quot;setting&quot;: &#123;    &quot;packNpmManually&quot;: true,    &quot;packNpmRelationList&quot;: [      &#123;        &quot;packageJsonPath&quot;: &quot;./package.json&quot;,        &quot;miniprogramNpmDistDir&quot;: &quot;./&quot;      &#125;    ]  &#125;&#125;\n\n打开”工具”-&gt;”构建 npm”，点击“确定”开始构建。\n\n\n","categories":["前端","微信小程序"],"tags":["npm"]}]