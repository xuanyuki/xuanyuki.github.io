[{"title":"Hello 算法（一）","url":"/c85c77c53426/Hello-%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/","content":"复杂度分析1. 算法效率评估算法效率主要包含两个维度：\n\n时间维度：算法的运行时间\n空间维度：算法运行过程中占用的内存大小\n\n效率评估方法主要分为两种：实际测试、理论估算。\n1.1 实际测试当我们拥有两个解决同一个问题的算法A和算法B，我们可以直接将其在同一台计算机上运行并监控记录它们的运行时间与内存占用情况，从而判断出哪个算法更优。但是这种方式虽然能反映实际情况，但是也会带来一些问题。\n\n在真实计算机环境下，计算机的硬件配置、操作系统、运行的其他进程等都会影响程序的运行时间。\n对算法进行完整测试需要大量资源，随着输入数据的变化算法表现出的效率也不同，因此需要大量的实验去验证。\n\n1.2 理论估算由于实际测试具有较大的局限性，我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。复杂度分析能够体现算法运行所需的时间和空间资源与输入数据规模之间的关系。它描述了随着输入数据规模的增加，算法执行所需时间和空间的增长趋势。复杂度分析克服了实际测试方法的弊端，体现在以下几个方面。\n\n它无需实际运行代码，更加绿色节能。\n它独立于测试环境，分析结果适用于所有运行平台。\n它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。\n\n2. 迭代与递归2.1 迭代迭代是重复执行一个任务的过程，在每次迭代中，程序需要满足一定的条件才能重复执行。\nfor 循环for 循环是最常见的迭代形式，适用于预先知道需要迭代的次数时使用。现在我们实现一个求和函数：\nfunction sum(n) &#123;  let res = 0;  for (let i = 1; i &lt;= n; i++) &#123;    res += i;  &#125;  return res;&#125;\n\n以下是该求和函数的流程图：\ngraph TD;\nA(开始) --&gt; B[初始化 i=1];\nsubgraph 循环\n  B--&gt; c&#123;i&lt;=n&#125; ;\n  c--真--&gt; D[执行任务] ;\n  D--&gt; E[执行 i+=1];\n  E --&gt; c;\nend\nc --假--&gt; F[结束];\n\n\n此求和函数的操作数量与输入数据大小 成正比，或者说成“线性关系”。实际上，时间复杂度描述的就是这个“线性关系”。相关内容将会在下一节中详细介绍。\nwhile 循环while 循环适用于预先不知道需要迭代的次数，但知道迭代结束条件的情况。在 while 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。现在我们实现一个求和函数：\nfunction sum(n) &#123;  let res = 0;  let i = 1;  while (i &lt;= n) &#123;    res += i;    i++;  &#125;  return res;&#125;\n\n嵌套循环嵌套循环指在一个循环中包含另一个循环。以 for 循环为例：\nfunction nestedForLoop(n) &#123;  let res = &quot;&quot;;  for (let i = 1; i &lt;= n; i++) &#123;    for (let j = 1; j &lt;= n; j++) &#123;      res += `($&#123;i&#125;, $&#123;j&#125;), `;    &#125;  &#125;  return res;&#125;\n\n以下是该函数的流程图：\ngraph TD;\nA(开始) --&gt; B[初始化 i=1];\nsubgraph 外层循环\n  B --&gt; C&#123;i&lt;=n&#125;;\n  C --真--&gt; D[执行任务];\n  I[执行 i+=1] --&gt; C;\n  C --假--&gt; END2[结束];\nend\nsubgraph 内层循环\n  D --&gt; E[初始化 j = 1];\n  E --&gt; F&#123;j&lt;=n&#125;;\n  F --真--&gt; G[执行任务];\n  G --&gt; H[执行 j+=1];\n  H --&gt; F;\n  F --假--&gt; END[结束];\n  END --&gt; I\nend\n\n此嵌套循环的操作数量与输入数据大小成“平方”关系。且当我们每一次添加一个嵌套循环时，时间复杂度会呈指数增长。\n2.2 递归递归主要通过函数调用自身来解决问题，它主要包含两个阶段：\n\n递：函数不断深入调用自身，直到达成终止条件。\n归：触发终止条件后，程序从深层开始将结果汇聚。\n\n在实现上，主要包含三个要素：\n\n终止条件\n递归调用\n返回结果\n\n接下来使用递归来完成求和函数：\nfunction sum(n) &#123;  if (n === 1) return 1;  const res = sum(n - 1);  return res + n;&#125;\n\n从计算角度看，递归与循环都可以得到同样的结果，但是他们的实际执行过程截然不同。\n\n迭代：“自下而上”，从基础步骤出发，不断地循环这个过程最后得出结果\n递归：“自上而下”，从最终目标出发，不断地将问题拆解为更小的子问题，直到达到终止条件\n\n调用栈由于函数在调用时，系统会单独为它分配一块内存空间，直到函数结束才会释放，所以当递归触发结束条件前系统会不断为它分配内存空间，这些内存空间被称为调用栈（call stack）。所以递归会比迭代更加的耗费内存空间，但是递归的时间效率通常比迭代更低。在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。\n尾递归尾递归是一种特殊的递归形式，如果函数在返回前的最后一步进行递归调用，则该函数可以被编译器或解释器优化，使其的空间效率与迭代相当。这种情况被称为尾递归。\n以求和函数为例：\nfunction sun(n, res) &#123;  if (n === 0) return res;  return sum(n - 1, res + n);&#125;\n\n递归树在处理“分治”类型的问题时，递归往往比迭代更加直观，以斐波那契数列为例：\nfunction fib(n) &#123;  if (n === 1 || n === 2) return 1;  const res = fib(n - 1) + fib(n - 2);  return res;&#125;\n\n现在我们在函数递归中每次调用了两个函数，如此不断递归，最终会形成一棵递归树，如下所示：\ngraph TD;\n  A(&quot;f(n)&quot;)\n  B(&quot;f(n-1)&quot;)\n  C(&quot;f(n-2)&quot;)\n  A --&gt; B\n  A --&gt; C\n  B --&gt; D(&quot;f(n-2)&quot;)\n  B --&gt; E(&quot;f(n-3)&quot;)\n  C --&gt; F(&quot;f(n-3)&quot;)\n  C --&gt; G(&quot;f(n-4)&quot;)\n  D --&gt; H(&quot;f(n-3)&quot;)\n  D --&gt; I(&quot;f(n-4)&quot;)\n  E --&gt; J(&quot;f(n-4)&quot;)\n  E --&gt; K(&quot;f(n-5)&quot;)\n  F --&gt; L(&quot;f(n-4)&quot;)\n  F --&gt; M(&quot;f(n-5)&quot;)\n  G --&gt; N(&quot;f(n-5)&quot;)\n  G --&gt; O(&quot;f(n-6)&quot;)\n\n2.3 对比\n\n\n\n迭代\n递归\n\n\n\n实现方式\n循环\n函数自调用\n\n\n时间效率\n时间效率较高，没有因为额外函数调用产生的开销\n每次递归都会产生开销\n\n\n内存使用\n固定大小\n根据递归的次数而定，次数越多内存消耗越大\n\n\n3. 时间复杂度现在我们知道了运行时间可以直观的反映算法的效率，而我们如何去预估代码的运行时间呢？\n现在假设加法操作需要 1 单位时间，乘法需要 10 单位时间，而输出需要 5 单位时间，以以下代码为例：\nfunction algorithm(n) &#123;  let a = 2; // 1  a = a + 1; // 1  a = a * 2; // 10  for (let i = 0; i &lt; n; i++) &#123;    // 1    console.log(i); // 5  &#125;&#125;\n\n根据以上代码我们算得：\n\n加法操作：1 次\n乘法操作：1 次\n输出操作：n 次\n循环操作中的加法操作：n 次\n\n即：$1 + 1 + 10 + 5n + n &#x3D; 6n + 12$\n3.1 统计时间增长趋势时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势。以下面代码为例：\n// 算法 A 的时间复杂度：常数阶function algorithm_A(n) &#123;  console.log(0);&#125;// 算法 B 的时间复杂度：线性阶function algorithm_B(n) &#123;  for (let i = 0; i &lt; n; i++) &#123;    console.log(0);  &#125;&#125;// 算法 C 的时间复杂度：常数阶function algorithm_C(n) &#123;  for (let i = 0; i &lt; 1000000; i++) &#123;    console.log(0);  &#125;&#125;\n\n\n算法 A 中无论 n 为何值，算法 A 的运行时间都是 1，所以该算法的时间复杂度为“常数阶”\n算法 B 中的打印操作根据 n 的变化而呈线性变化，且运行时间根据 n 的变化而线性变化。所以该算法的时间复杂度为“线性阶”\n算法 C 中无论 n 为何值，算法 C 的运行时间都是 1000000，所以该算法的时间复杂度依然为“常数阶”\n\n\n\n\n\n  if (window.eChartecharts1290ResizeHandler) {\n    window.removeEventListener(\"resize\", eChartecharts1290ResizeHandler);\n  }\n  var optionecharts1290 = {\n\"title\": {\n\"text\": \"算法运行时间\",\n\"left\": \"center\",\n\"textStyle\": {\n\"fontSize\": 16,\n\"fontWeight\": \"bold\"\n}\n},\n\"tooltip\": {\n\"show\":false\n},\n\"legend\": {\n\"data\": [\"算法 C - 常数阶\", \"算法 B - 线性阶\", \"算法 A - 常数阶\"],\n\"top\": \"8%\"\n},\n\"grid\": {\n\"left\": \"10%\",\n\"right\": \"10%\",\n\"bottom\": \"15%\",\n\"top\": \"20%\"\n},\n\"xAxis\": {\n\"name\": \"输入数据大小 n\",\n\"nameLocation\": \"middle\",\n\"nameGap\": 30,\n\"type\": \"value\",\n\"min\": 0,\n\"max\": 9,\n\"interval\": 1,\n\"axisLine\": {\n\"show\": true\n},\n\"axisTick\": {\n\"show\": true\n}\n},\n\"yAxis\": {\n\"name\": \"算法运行时间\",\n\"type\": \"value\",\n\"min\": 0,\n\"max\": 9,\n\"interval\": 1,\n\"axisLine\": {\n\"show\": true\n},\n\"axisTick\": {\n\"show\": true\n}\n},\n\"series\": [\n{\n\"name\": \"算法 C - 常数阶\",\n\"type\": \"line\",\n\"data\": [[0, 1], [9, 1]],\n\"lineStyle\": {\n\"color\": \"#5470c6\",\n\"width\": 2\n},\n\"symbol\": \"none\"\n},\n{\n\"name\": \"算法 B - 线性阶\",\n\"type\": \"line\",\n\"data\": [[0, 0], [9, 9]],\n\"lineStyle\": {\n\"color\": \"#91cc75\",\n\"width\": 2\n},\n\"symbol\": \"none\"\n},\n{\n\"name\": \"算法 A - 常数阶\",\n\"type\": \"line\",\n\"data\": [[0, 2], [9, 2]],\n\"lineStyle\": {\n\"color\": \"#fac858\",\n\"width\": 2\n},\n\"symbol\": \"none\"\n}\n]\n};\n  if (window.echarts !== undefined) {\n    var eChartecharts1290 = echarts.init(document.getElementById('echarts1290'));\n    eChartecharts1290.setOption(optionecharts1290);\n    var eChartecharts1290ResizeHandler = function() {\n      eChartecharts1290.resize();\n    };\n    window.addEventListener(\"resize\", eChartecharts1290ResizeHandler);\n  }\n\n\n算法 A、B 和 C 的时间增长趋势\n\n时间复杂度分析的特点：\n\n时间复杂度能够有效评估算法效率。当输入数据足够大，常数阶的算法一定优于线性阶。\n时间复杂度的推算方法更简便。不需要考虑运行环境，将所有算法统一以“单位时间”为基准，将时间统计转为数量统计。\n时间复杂度也存在一定的局限性。可能会出现两个不同算法的时间复杂度相同但实际运行时间不同；算法 A 比算法 B 时间复杂度高，但是输入数据很小时出现的算法 A 比算法 B 实际运行时间短的问题。\n\n3.2 函数渐进上界给定一个输入为 n 的函数：\nfunction algorithm(n) &#123;  let res = 0;  res += 1;  res *= 2;  for (let i = 0; i &lt; n; i++) &#123;    console.log(i);  &#125;&#125;\n\n该函数的操作数量为：$3+2n$由于该函数是一次函数，所以该算法的运行时间根据输入n呈线性增长，所以它的复杂度为线性阶。现在我们将线性阶的时间复杂度记为$O(n)$,其中$O$表示函数的渐进上界。\n\n函数渐近上界\n若存在正实数 $c$ 和实数$n_0$，使所有对于$n>n_0$时，均有，$T(n) \\leqslant c \\cdot f(n)$，则可认为$f(n)$给出了$T(n)$的一个渐进上界，标记为$T(n) = O(f(n))$。\n3.3 推算方法3.3.1 统计操作数量\n忽略$T(n)$中的常数。常数不影响时间复杂度。\n省略所有系数。如$2n$和$5n+1$的时间复杂度相同，都记为$n$次。\n循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积。如：$3n^2 + 2n$的时间复杂度为$O(n^2)$。\n\nfunction algorithm(n) &#123;  let a = 1; // 常数阶 记为0  a = a + n; // 常数阶 记为0  // 线性阶 记为n  for (let i = 0; i &lt; 5 * n + 1; i++) &#123;    console.log(0);  &#125;  // 嵌套循环 记为n*n  for (let i = 0; i &lt; 2 * n; i++) &#123;    for (let j = 0; j &lt; n + 1; j++) &#123;      console.log(0);    &#125;  &#125;&#125;\n\n根据以上方法统计出该程序的时间复杂度为：$O(n^2)$。完整统计：$T(n)&#x3D;2n(n+1)+(5n+1)+2$$&#x3D; 2n^2 + 7n + 3$根据方法省略统计：$T(n)&#x3D;n^2+n$\n3.3.2 判断渐近上界时间复杂度由$T(n)$中的最高阶的项决定。因为在n趋向于无穷大时，最高阶的项发挥主导作用，可以忽略其他项的影响。\n不同操作数量对应的时间复杂度：\n\n\n\n操作数量$T(n)$\n时间复杂度$O(f(n))$\n\n\n\n10000\n$O(1)$\n\n\n$3n+2$\n$O(n)$\n\n\n$2n^2+3n+2$\n$O(n^2)$\n\n\n$n^3+10000n^2$\n$O(n^3)$\n\n\n$2^n+10000n^10000$\n$O(2^n)$\n\n\n3.4 常见时间复杂度类型设输入数据为n，场景的时间复杂度如下：\n$O(1) &lt; O(\\log n) &lt; O(n)&lt;O(n \\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)$常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt;br 平方阶 &lt;br 指数阶 &lt;br 阶乘阶\n\n常数阶$O(1)$：常数阶的操作数量与输入数据大小 $n$ 无关，即不随着 $n$ 的变化而变化。\n线性阶$O(n)$：线性阶的操作数量相对于输入数据大小 $n$ 以线性级别增长。\n平方阶$O(n^2)$：平方阶的操作数量相对于输入数据大小 $n$ 以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为 $O(n)$ ，因此总体的时间复杂度为：$O(n^2)$。\n指数阶$(O(2^n))$：生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推，分裂 $n$ 轮后有 $2^n$ 个细胞。\n对数阶$O(log n)$：与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。\n线性对数阶$O(n log n)$：线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 $O(log n)$ 和 $O(n)$。\n阶乘阶$O(n!)$：阶乘阶对应数学上的“全排列”问题。给定 $n$ 个互不重复的元素，求其所有可能的排列方案，方案数量为：$n! &#x3D; n \\times (n-1) \\times (n-2) \\times … \\times 2 \\times 1$。\n\n3.5 最差、最佳、平均时间复杂度算法的时间效率往往不是固定的，而是与输入数据的分布有关。假如一个数组长度为 n，且最后一个元素为 1 ，当我们需要找到值为 1 的元素时，需要完整遍历整个数组，这时该算法就达到最差时间复杂度，即：$O(n)$。反之，当数组中的第一个元素为 1 时，我们只需要遍历一次就能找到，这时该算法就达到最佳时间复杂度，即：$\\Omega(1)$。“最差时间复杂度”对应函数渐进上界，使用大$O$表示；“最佳时间复杂度”则对应函数渐进下界，使用大$\\Omega$表示。相比之下，平均时间复杂度可以体现算法在随机输入数据下的运行效率，则使用大$\\Theta$表示。\n4. 空间复杂度空间复杂度用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。\n4.1 算法相关空间算法在运行过程中使用的内存空间主要包括以下几种。\n\n输入空间：输入的数据\n暂存空间：算法运行过程中使用的临时变量\n输出空间：输出的数据\n\n一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。\n暂存空间可以分为三部分：\n\n暂存数据：用于保存算法运行过程中的数据\n栈帧空间：用于保存算法函数调用时的上下文数据\n指令空间：用于保存算法运行过程中的指令，实际可以忽略不计\n\n4.2 推算方法空间复杂度的推算方法与时间复杂度大致相同，只需将“操作数量”转为“占用内存空间”即可。与时间复杂度不同，对于空间复杂度通常只关注“最差空间复杂度”，因为我们需要确保算法在运行过程中不会出现内存不足的情况。在递归函数中，需要注意统计栈帧空间。\n4.3 常见空间复杂度类型\n\n\n空间复杂度\n算法场景\n\n\n\n$O(1)$\n常数阶\n\n\n$O(\\log n)$\n对数阶\n\n\n$O(n)$\n线性阶\n\n\n$O(n^2)$\n平方阶\n\n\n$O(2^n)$\n指数阶\n\n\n\n常数阶$O(1)$：常数阶的空间复杂度表示算法运行过程中占用的内存空间与输入数据大小 $n$ 无关，即不随着 $n$ 的变化而变化。在循环内部初始化的变量或者调用函数占用的内存，在下一次循环时会释放，所以不需要考虑。\n线性阶$O(n)$：线性阶常见于元素数量与输入数据大小 $n$ 成正比的场景，如：数组、链表、队列、栈等。\n平方阶$O(n^2)$：平方阶常见于元素数量与输入数据大小 $n$ 成平方关系的场景，如：二维数组、矩阵等。\n指数阶$O(2^n)$：指数阶常见于二叉树。\n对数阶$O(\\log n)$：对数阶常见于分治，如：二分查找、快速排序、归并排序等。\n\n","categories":["算法"],"tags":["算法","笔记","Hello 算法"]},{"title":"JavaScript忍者秘籍（一）","url":"/ebaa4fc9c186/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%B8%80%EF%BC%89/","content":"web应用运行时的构建过程生命周期\n从用户在浏览器地址栏输入URL或者点击链接开始，浏览器向服务器请求了由HTML、CSS、JavaScript组成的资源。当浏览器接收到这些资源，我们的web应用正式开启它的生命周期。\n\n\n执行步骤如下：\n\n页面构建——浏览器解析HTML，构建DOM树；解析CSS，构建CSSOM树，解析JavaScript，执行代码。\n事件处理——浏览器等待用户交互并在事件发生时执行事件处理程序。\n\n当用户离开或关闭页面时，该web应用的生命周期结束。\n页面构建当web应用被请求完成但可以被展示或交互之前，浏览器需要根据服务器响应的HTML、CSS和JavaScript完成对页面的构建：\n\n解析HTML，构建DOM树\n执行JavaScript——在浏览器解析HTML的过程中，如果遇到JavaScript脚本标签（&lt;script&gt;），浏览器会停止构建DOM树，执行该段代码；随后继续构建DOM树。\n\n事件处理概览由于浏览器的事件处理机制为单线程执行模型，为实现它，浏览器使用了任务队列机制，所有已生成的事件（无论是用户生成的，例如鼠标移动或键盘点击，还是服务器生成的，例如Ajax事件）都会放在同一个事件队列中，以它们被浏览器检测到的顺序排列。\n\n浏览器检查事件队列头；\n如果浏览器没有在队列中检测到事件，则继续检查；\n如果浏览器在队列头中检测到了事件，则取出该事件并执行相应的事件处理器（如果存在）。在这个过程中，余下的事件在事件队列中耐心等待，直到轮到它们被处理\n\n\n事件可能会以难以预计的时间和顺序发生，我们对事件的处理，以及处理函数的调用是异步的。如下类型的事件会在其他类型事件中发生：\n\n浏览器事件，例如当页面加载完成后或无法加载时；\n网络事件，例如来自服务器的响应（Ajax事件和服务器端事件）；\n用户事件，例如鼠标单击、鼠标移动和键盘事件；\n计时器事件，当timeout时间到期或又触发了一次时间间隔。\n\n注册事件处理器在JavaScript中，我们可以通过两种方式注册事件处理器：\n\n将事件处理函数赋给特定属性\n调用addEventListener()方法\n\n处理事件事件处理背后的主要思想是：当事件发生时，浏览器调用相应的事件处理器。由于单线程执行模型，所以浏览器同一时刻只能处理一个事件，且处理顺序是事件生成的顺序。任何后面的事件都只能在当前事件处理器完全结束执行后才能被处理！\n","categories":["前端","javascript"],"tags":["笔记","前端","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript忍者秘籍（三）","url":"/40ebbe81ddb2/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%B8%89%EF%BC%89/","content":"生成器1. 使用生成器函数function* myGenerator() &#123;  yield 1;  yield 2;&#125;\n\n创建一个生成器很简单，只需要在函数声明中使用一个星号*。这样就可以在生成器函数中使用yield关键字了。\nfor (const value of myGenerator()) &#123;  console.log(value); // 1 2&#125;\n\nfor-of 的执行结果如注释所示，当我们使用生成器时并没有使用return关键字。实际上调用生成器并不会执行生成器函数，而是会创建一个迭代器对象。\n2. 通过迭代器对象控制生成器/** 定义了一个生成器函数 */function* WeaponGenerator() &#123;  yield &quot;Katana&quot;;  yield &quot;Wakizashi&quot;;&#125;const weaponsIterator = WeaponGenerator(); // 创建迭代器对象const result1 = weaponsIterator.next(); // &#123; value: &quot;Katana&quot;, done: false &#125;const result2 = weaponsIterator.next(); // &#123; value: &quot;Wakizashi&quot;, done: false &#125;const result3 = weaponsIterator.next(); // &#123; value: undefined, done: true &#125;\n\n在调用生成器后，我们得到了一个迭代器对象。通过调用next()方法可以逐个访问生成器的值。每次调用next()方法，都会返回一个对象，其中封装了结果值和一个指示完成的指示器。\n每当生成一个当前值后，生成器就会非阻塞地挂起执行，随后耐心等待下一次值请求的到达。\n在以上代码中，由于第三次调用next()方法时，生成器已经无法再生成值了，因此返回了一个done: true且value: undefined的对象。\n跟在函数中调用函数一样，我们可以在生成器中调用另一个生成器：\nfunction* WeaponGenerator() &#123;  yield &quot;Katana&quot;;  yield* WeaponGenerator2(); // 委托给另一个生成器  yield &quot;Wakizashi&quot;;&#125;function* WeaponGenerator2() &#123;  yield &quot;Shuriken&quot;;  yield &quot;Kunai&quot;;&#125;for (const value of WeaponGenerator()) &#123;  console.log(value);&#125;\n\n执行上述代码会输出 &quot;Katana&quot;、&quot;Shuriken&quot;、&quot;Kunai&quot;和&quot;Wakizashi&quot;。因为在迭代器上使用 yield*操作符，程序会跳转到另外一个生成器上执行。\n3. 使用生成器使用生成器生成 idfunction* idGenerator() &#123;  let id = 0;  while (true) &#123;    yield id++;  &#125;&#125;const iter = idGenerator();console.log(iter.next().value); // 0console.log(iter.next().value); // 1console.log(iter.next().value); // 2\n\n使用生成器遍历 DOM 树&lt;div id=&quot;subTree&quot;&gt;  &lt;form&gt;    &lt;input type=&quot;text&quot; /&gt;  &lt;/form&gt;  &lt;p&gt;Paragraph&lt;/p&gt;  &lt;span&gt;Span&lt;/span&gt;&lt;/div&gt;&lt;script&gt;  function* domTreeGenerator(node) &#123;    yield node;    for (const child of node.children) &#123;      yield* domTreeGenerator(child); // 委托给该节点的子节点生成器      node = node.nextElementSibling; // 将当前节点指向下一个兄弟节点    &#125;  &#125;  const subTree = document.getElementById(&quot;subTree&quot;);  for (const node of domTreeGenerator(subTree)) &#123;    console.log(node.nodeName);  &#125;&lt;/script&gt;\n\n4. 与生成器交互通过生成器函数参数发送值function* myGenerator(action) &#123;  const result = yield action;  yield result;&#125;const iter = myGenerator(&quot;Hello&quot;);const r1 = iter.next(); // &#123; value: &quot;Hello&quot;, done: false &#125;const r2 = iter.next(&quot;World&quot;); // &#123; value: &quot;World&quot;, done: false &#125;\n\n如果在r2中没有传入值，那么结果将是&#123;value: undefined, done: false&#125;。\n通过next方法发送值除了在第一次调用生成器的时候向生成器提供数据，我们还能通过next方法向生成器传入参数。在这个过程中，我们把生成器函数从挂起状态恢复到了执行状态。生成器把这个传入的值用于整个yield表达式（生成器当前挂起的表达式）的值。\n5. 生成器的内部构成一个生成器的工作流程如下：\n\n挂起开始——创建了一个生成器后，它最先以这种状态开始。其中的任何代码都未执行。\n执行——生成器中的代码执行的状态。执行要么是刚开始，要么是从上次挂起的时候继续的。当生成器对应的迭代器调用了next方法，并且当前存在可执行的代码时，生成器都会转移到这个状态。\n挂起让渡——当生成器在执行过程中遇到了一个yield表达式，它会创建一个包含着返回值的新对象，随后再挂起执行。生成器在这个状态暂停并等待继续执行。\n完成——在生成器执行期间，如果代码执行到return语句或者全部代码执行完毕，生成器就进入该状态。\n\n\n","categories":["前端","javascript"],"tags":["笔记","前端","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript忍者秘籍（二）","url":"/de0931cb981b/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"闭包和作用域\n闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。\n\n使用闭包1. 封装私有变量function n()&#123;  let count = 0;  this.getCount = function()&#123;    return count;  &#125;  this.countPlus = function()&#123;    count++;  &#125;&#125;const n1 = new n();n1.countPlus();console.log(n1.count); // undefined 无法直接访问到count变量console.log(n1.getCount()); // 1 通过闭包访问到count变量const n2 = new n();console.log(n2.getCount()); // 0 n1和n2是两个独立的实例，互不影响\n\n在构造器 n 中，我们定义了一个 count 变量来保存状态，由于 count 变量是在构造器内部定义的，因此外部无法直接访问到它。但是通过闭包的方式，我们可以通过 getCount() 和 countPlus() 方法来间接地操作这个私有变量。而像 getCount() 这中只读访问的方法被称为 getter 方法，而像 countPlus() 这样仅修改私有变量的方法被称为 setter 方法。\n2. 回调函数\n回调函数指的是需要在将来不确定的某一时刻异步调用的函数。通常，在这种回调函数中，我们经常需要频繁地访问外部数据。\n\n&lt;div id=&quot;box1&quot;&gt;First Box&lt;/div&gt;&lt;script&gt;  function animate(element)&#123;    const el = document.getElementById(element);    let tick = 0;    let timer = setInterval(function()&#123;      if(tick &lt; 100)&#123;        el.style.left = el.style.top = `$&#123;tick&#125;px`;        tick++;      &#125; else &#123;        clearInterval(timer);      &#125;    &#125;, 10)  &#125;  animate(&#x27;box1&#x27;);&lt;/script&gt;\n\n\n\n  \n    First Box\n    \n      function animate(element){\n        const el = document.getElementById(element);\n        let tick = 0;\n        let timer = setInterval(function(){\n          if(tick < 100){\n            el.style.marginLeft = `${tick}px`;\n            tick++;\n          } else {\n            clearInterval(timer);\n          }\n        }, 10)\n      }\n      animate('box1')\n    \n  \n\n\n\n\n闭包内的函数不仅可以在创建的时刻访问这些变量，而且当闭包内部的函数执行时，还可以更新这些变量的值。闭包不是在创建的那一时刻的状态的快照，而是一个真实的状态封装，只要闭包存在，就可以对变量进行修改。\n\njs的变量类型在词法环境中注册标识符const first = &#x27;first&#x27;;check(first)function check(val)&#123;  console.log(val);&#125;\n由以上代码可以看出：JavaScript对于在哪儿定义函数并不挑剔。在调用函数之前或之后声明函数均可。\n注册标识符的过程\n\n如果是创建一个函数环境，那么创建形参及函数参数的默认值。如果是非函数环境，将跳过此步骤。\n如果是创建全局或函数环境，就扫描当前代码进行函数声明（不会扫描其他函数的函数体），但是不会扫描函数表达式或箭头函数。对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上。若该标识符已经存在，那么该标识符的值将被重写。如果是块级作用域，将跳过此步骤。\n扫描当前代码，查找其中的变量声明。先去查找当前函数以及其他函数之外定义的 var 变量，再去寻找所有在其他函数或代码块之外定义的 let 和 const 变量。在块级环境中仅查找当前块中定义的 let 和 const 变量。对于找到的每个变量声明，在当前环境中创建该变量的标识符，并将其初始化为 undefined，若标识符已存在则保留原有值。\n\ngraph TD;\n   A&#123;当前是否为函数环境？&#125;\n   A --&gt; |是|B(创建函数的参数对象arguments和形参)\n   A --&gt; |否|C&#123;当前环境是全局环境或函数环境？&#125;\n   B --&gt; C\n   C --&gt; |是|D(注册其他函数外的函数声明)\n   C --&gt; |否|E&#123;当前环境是否为块级作用域&#125;\n   D --&gt; E\n   E --&gt; |是|F(注册当前块内的let和const变量)\n   E --&gt; |否|G(注册函数作用域之外的var变量以及在其他函数或代码块之外定义的let和const变量)\n\n闭包的工作原理私有变量现在我们使用前文的例子再次模拟私有变量。\nfunction n()&#123;  let count = 0;  this.getCount = function()&#123;    return count;  &#125;  this.countPlus = function()&#123;    count++;  &#125;&#125;const n1 = new n();n1.countPlus();console.log(n1.count); // undefined 无法直接访问到count变量console.log(n1.getCount()); // 1 通过闭包访问到count变量const n2 = new n();console.log(n2.getCount()); // 0 n1和n2是两个独立的实例，互不影响\n\njavaScript引擎在通过 new 关键字创建 n 函数时，会创建一个新的词法环境，每个词法环境都会包含一份构造函数 n 的局部变量。由于我们在 n 函数中定义了 getCount 和 countPlus 函数，所以这些函数均包含 n 函数的词法环境。\n因为 getCount 和 countPlus 函数是在 n 中新创建的方法（可以通过this关键字访问）。所以可以在 n 函数的外部访问到这些函数，此时就创建了一个包含 count 变量的闭包。\n回调函数这次我们改造前文回调函数\n&lt;div id=&quot;box1&quot;&gt;First Box&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt;second Box&lt;/div&gt;&lt;script&gt;  function animate(element)&#123;    const el = document.getElementById(element);    let tick = 0;    let timer = setInterval(function()&#123;      if(tick &lt; 100)&#123;        el.style.left = el.style.top = `$&#123;tick&#125;px`;        tick++;      &#125; else &#123;        clearInterval(timer);      &#125;    &#125;, 10)  &#125;  animate(&#x27;box1&#x27;);  animate(&#x27;box2&#x27;);&lt;/script&gt;\n在每次调用 animate 函数时，都会创建一个新的词法环境，该词法环境包含了动画所需的变量。只要有一个通过闭包访问这些变量的函数存在，那么这些变量就不会被销毁。即在以上代码中，setInterval 的回调函数会一直存在，直到调用 clearInterval 方法。\n总结\n通过闭包可以访问闭包创建时所处词法环境中的所有变量，通过这种方式，即使创建函数时所处的作用域已经消失，我们仍然可以访问到这些变量。\n可以通过闭包来实现以下功能：\n通过构造函数内的变量以及构造方法来模拟私有变量\n处理回调函数，简化代码\n\n\n闭包是JavaScript作用域规则的副作用。当函数创建时所在的作用域消失后，仍然能够调用函数。\nJavaScript引擎通过词法环境跟踪标识符（俗称作用域）。\nJavaScript引擎通过执行上下文栈（调用栈）跟踪函数的执行。每次调用函数时，都会创建新的函数执行上下文，并推入调用栈顶端。当函数执行完成后，对应的执行上下文将从调用栈中推出（在js代码执行时默认会创建一个全局的执行上下文）。\n\n","categories":["前端","javascript"],"tags":["笔记","前端","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript忍者秘籍（四）","url":"/a4b5ed670eba/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"原型理解原型\n每个对象都含有原型的引用，当查找属性时，若对象本身不具有该属性，则会查找原型上是否有该属性。\n每个对象都可以有一个原型，每个对象的原型也可以拥有一个原型，以此类推，形成一个原型链。查找特定属性将会被委托在整个原型链上，只有当没有更多的原型可以进行查找时，才会停止查找。\n\n对象构造器与原型首先我们创建一个最简单的对象：\nconst person = &#123;&#125;;\n\n之后我们可以通过赋值语句给它添加属性：\nconst person = &#123;&#125;;person.name = &quot;张三&quot;;person.age = 20;\n\n如果我们要创建一个拥有相同属性的多个对象，我们可以使用构造函数。但是构造函数是用来初始化对象为已知的初始状态。毕竟，如果我们要创建多个相同类型的对象的实例，为每个实例单独进行属性分配，不仅繁琐，而且非常容易出错。我们希望能够在一个地方将这些对象的属性和方法整合为一个类。\nJavaScript 通过构造函数初始化新对象，但是没有真正的类定义。通过操作符new，应用于构造函数之前，触发创建一个新对象分配。\n还有一点是，每个函数都有一个原型对象，该原型对象被自动设置为通过该函数创建的每个新对象的原型。\nfunction fun1() &#123;&#125;fun1.prototype.action = function () &#123;  return true;&#125;;const obj1 = fun1();console.log(obj1); // undefinedconst obj2 = new fun1();console.log(obj2); // fun1&#123;&#125;\n\n通过以上代码可以看出，通过new关键字创建出的对象包含了fun1函数原型上的方法。\n实例属性当把函数作为构造函数，通过操作符new进行调用时，它的上下文被定义为新的对象实例。通过原型暴露属性，通过构造函数的参数进行初始化。\nfunction Ninja() &#123;  this.swung = true;  this.swingSword = function () &#123;    return !this.swung;  &#125;;&#125;Ninja.prototype.swingSword = function () &#123;  return this.swung;&#125;;const ninja = new Ninja();console.log(ninja.swingSword()); // false\n\nJavaScript 动态特性的副作用由于 JavaScript 的动态特性，我们可以在运行时给对象添加属性。\nfunction Ninja() &#123;  this.swung = true;&#125;const ninja1 = new Ninja(); // 创建一个Ninja实例/** 在实例创建后向原型上添加一个方法 */Ninja.prototype.swingSword = function () &#123;  return this.swung;&#125;;/** 验证实例上有没有实例化后的新增方法 */console.log(ninja1.swingSword()); // true/** 重写Ninja的原型 */Ninja.prototype = &#123;  pierce: function () &#123;    return true;  &#125;,&#125;;/** 由于实例保留原有的原型对象，所以在实例化之后对原型的重写不会被应用在已经创建的实例上 */console.log(ninja1.pierce()); // Uncaught TypeError: ninja1.pierce is not a functionconst ninja2 = new Ninja();/** 最新的实例会应用最新的原型对象 */console.log(ninja2.pierce()); // true\n\n所以我们得到一个结论：对象与函数原型之间的引用关系是在对象创建时建立的，新创建的对象将引用新的原型，而旧的对象会保留着原有的原型引用。\n通过构造函数实现函数对象function Ninja() &#123;&#125;const ninja = new Ninja();console.log(ninja instanceof Ninja); // true\n\n通过示例我们可以使用instanceof操作符来判断对象是否为某个构造函数的实例。接下来我们可以使用对象的constructor属性来创建新的对象。\nfunction Ninja() &#123;&#125;const ninja = new Ninja();const ninja2 = new ninja.constructor();/** * 由于ninja的constructor属性是Ninja原型的引用 * 所以通过constructor创建的ninja2也是Ninja的实例 */console.log(ninja2 instanceof Ninja); // true/** 但是两个对象是独立的 */console.log(ninja2 === ninja); // false\n\n使用原型实现继承function Person() &#123;&#125;Person.prototype.dance = function () &#123;&#125;;function Ninja() &#123;&#125;Ninja.prototype = new Person(); // 通过将原型设为实例化后的Person对象，实现继承const ninja = new Ninja();console.log(ninja instanceof Ninja); // trueconsole.log(ninja instanceof Person); // trueconsole.log(ninja instanceof Object); // trueconsole.log(typeof ninja.dance === &quot;function&quot;); // true\n\n原型关系图:\ngraph TD;\nA[ninja实例] --&gt;|__proto__| B[new Person&lt;br&gt;Ninja.prototype]\n    B --&gt;|__proto__| C[Person.prototype&lt;br&gt;包含dance方法]\n    C --&gt;|__proto__| D[Object.prototype]\n    D --&gt;|__proto__| E[null]\n\n    F[instanceof Ninja: true] --&gt; A\n    G[instanceof Person: true] --&gt; A\n    H[instanceof Object: true] --&gt; A\n    I[ninja.dance: function] --&gt; A\n\n    B -.-&gt;|constructor| J[Person构造函数]\n    C -.-&gt;|constructor| J\n\n    style A fill:#e1f5fe\n    style B fill:#fff3e0\n    style C fill:#f3e5f5\n    style D fill:#e8f5e8\n    style J fill:#ffebee\n\n解决继承中构造器constructor被覆盖的问题为了使Ninja继承Person，我们使用了Ninja.prototype = new Person();。但是这会覆盖掉原型上的constructor属性，使ninja.constructor指向Person，而不是Ninja。这导致了我们的ninja丢失了与Ninja构造函数之间的联系。此时我们可以通过Object.defineProperty方法来修正这个问题。\n\nJavaScript中，对象是通过属性描述（property descriptor）进行描述的，我们可以配置以下关键字。\n\nconfigurable —— 如果设为true，则可以修改或删除属性。如果设为false，则不允许修改。\nenumerable —— 如果设为true，则可在for-in循环对象属性时出现。\nvalue —— 指定属性的值，默认为undefined。\nwritable —— 如果设为true，则可通过赋值语句修改属性值。\nget —— 定义getter函数，当访问属性时发生调用，不能与value与writable同时使用。\nset —— 定义setter函数，当对属性赋值时发生调用，也不能与value与writable同时使用。\n\n\nfunction Person() &#123;&#125;Person.prototype.dance = function () &#123;&#125;;function Ninja() &#123;&#125;Ninja.prototype = new Person();/** 手动设置constructor属性，将其重置为Ninja */Object.defineProperty(Ninja.prototype, &quot;constructor&quot;, &#123;  enumerable: false,  value: Ninja,  writable: true,&#125;)const ninja = new Ninja();console.log(ninja instanceof Ninja); // trueconsole.log(ninja instanceof Person); // true\n\n使用ES6定义类class Ninja &#123;&#125;const ninja = new Ninja();\n继承class Person &#123;  dance()&#123;    return true;  &#125;&#125;class Ninja extends Person &#123;  constructor() &#123;    super(); // 调用父类的构造函数  &#125;&#125;const ninja = new Ninja();console.log(ninja instanceof Ninja); // trueconsole.log(ninja instanceof Person); // trueconsole.log(ninja.dance()); // true\n使用es6的语法，我们不需要手动设置原型和构造器。\n","categories":["前端","javascript"],"tags":["笔记","前端","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript忍者秘籍（五）","url":"/1d049a349d75/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%BA%94%EF%BC%89/","content":"事件事件循环\n事件循环不仅仅包含事件队列，而是具有至少两个队列，除了事件，还要保持浏览器执行的其他操作。这些操作被称为任务，并且分为两类：宏任务（或通常称为任务）和微任务。\n宏任务的例子很多，包括创建主文档对象、解析HTML、执行主线（或全局）JavaScript代码，更改当前URL以及各种事件，如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，宏任务代表一个个离散的、独立工作单元。运行完任务后，浏览器可以继续其他调度，如重新渲染页面的UI或执行垃圾回收。\n而微任务是更小的任务。微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。微任务的案例包括promise回调函数、DOM发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使应用程序的状态不连续。\n\n事件循环基于两个基本原则：\n\n一次处理一个任务。\n一个任务开始后直到运行完成，不会被其他任务中断。\n\n\n在每一次迭代中，事件循环会首先检测宏任务队列，如果有宏任务再等待执行，则开始执行宏任务，当该任务执行完毕或宏任务队列为空时，事件循环会检测微任务队列。如果有微任务等待执行，则执行所有可用的微任务。\n\n每次迭代时仅执行一个宏任务，但会执行所有的微任务。\n\n当微任务队列为空时，事件循环会检查是否需要更新UI渲染，完成后，事件循环会再次回到宏任务队列执行下一次迭代。\n至此：\n\n任务队列是独立于事件循环的，且任务队列的添加行为也独立于事件循环。\n由于JavaScript是单线程的，所以当一个任务正在执行时不会被其他任何任务打断，除非浏览器决定中止该任务（任务执行时间过长或者任务占用内存过大）。\n所有微任务都会在下一次渲染前完成，因为它们的目标是在渲染前更新应用程序状态。\n浏览器通常会尝试每秒渲染60次页面，以达到每秒60帧（60 fps）的速度。这意味着浏览器会尝试在16ms内渲染一帧。理想情况下，单个任务和该任务附属的所有微任务，都应在16ms内完成。\n\n","categories":["前端","javascript"],"tags":["笔记","前端","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript设计模式","url":"/4fbd70990c3a/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"\n设计模式原则：\n\nS – Single Responsibility Principle 单一职责原则\n一个程序只做好一件事\n如果功能过于复杂就拆分开，每个部分保持独立\n\n\nO – OpenClosed Principle 开放&#x2F;封闭原则\n对扩展开放，对修改封闭\n增加需求时，扩展新代码，而非修改已有代码\n\n\nL – Liskov Substitution Principle 里氏替换原则\n子类能覆盖父类\n父类能出现的地方子类就能出现\n\n\nI – Interface Segregation Principle 接口隔离原则\n保持接口的单一独立\n类似单一职责原则，这里更关注接口\n\n\nD – Dependency Inversion Principle 依赖倒转原则\n面向接口编程，依赖于抽象而不依赖于具体\n使用方只关注接口而不关注具体类的实现\n\n\n\n\n1. 单例模式\n单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n1.1 实现function Singleton(name) &#123;  this.name = name;  this.instance = null;&#125;Singleton.prototype.getName = function () &#123;  return this.name;&#125;;Singleton.getInstance = function (name) &#123;  if (!this.instance) &#123;    this.instance = new Singleton(name);  &#125;  return this.instance;&#125;;const a = Singleton.getInstance(&quot;a&quot;);const b = Singleton.getInstance(&quot;b&quot;);console.log(a === b); // true\n\n如以上代码，无论何时访问Singleton.getInstance()，都会返回同一个实例。\n1.2 使用代理实现class CreateDiv &#123;  html = null;  constructor(html) &#123;    this.html = html;  &#125;  init() &#123;    const div = document.createElement(&quot;div&quot;);    div.innerHTML = this.html;    document.body.appendChild(div);  &#125;&#125;/** 代理类 */const ProxySingletonCreateDiv = (function () &#123;  let instance = null;  return class &#123;    constructor(html) &#123;      if (!instance) &#123;        instance = new CreateDiv(html);      &#125;      return instance;    &#125;  &#125;;&#125;)();const a = new ProxySingletonCreateDiv(&quot;sven1&quot;);const b = new ProxySingletonCreateDiv(&quot;sven2&quot;);console.log(a === b); // true\n\n2. 工厂模式\n工厂模式提供一个创建对象的接口，通过这个接口可以创建不同的对象。可以通过类和工厂函数实现。\n\n2.1 使用类实现class Person &#123;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  say() &#123;    console.log(`$&#123;this.name&#125; say: &#x27;Hello!&#x27;`);  &#125;&#125;const zhangsan = new Person(&quot;张三&quot;, 18);console.log(zhangsan.name); // 张三\n\n2.2 使用工厂函数实现function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;Person.prototype.say = function () &#123;  console.log(`$&#123;this.name&#125; say: &#x27;Hello!&#x27;`);&#125;;const zhangsan = new Person(&quot;张三&quot;, 18);console.log(zhangsan.name); // 张三\n\n3. 抽象工厂模式\n抽象工厂通过特定逻辑调用工厂，通过工厂返回最终对象。\n\nclass Apple &#123;  constructor() &#123;    this.name = &quot;Apple&quot;;  &#125;  getType() &#123;    return this.name;  &#125;&#125;class Banana &#123;  constructor() &#123;    this.name = &quot;Banana&quot;;  &#125;  getType() &#123;    return this.name;  &#125;&#125;const FruitFactory = &#123;  getFruit: function (type) &#123;    switch (type) &#123;      case &quot;apple&quot;:        return new Apple();      case &quot;banana&quot;:        return new Banana();      default:        return null;    &#125;  &#125;,&#125;;const apple = FruitFactory.getFruit(&quot;apple&quot;);const banana = FruitFactory.getFruit(&quot;banana&quot;);console.log(apple.getType()); // Appleconsole.log(banana.getType()); // Banana\n\n4. 构造器模式\n构造器模式通过不同的函数以及方法向对象添加属性和方法。\n\nconst zhangsan = &#123;  name: &quot;张三&quot;,  age: 18,&#125;;const lisi = &#123;  name: &quot;李四&quot;,  age: 20,&#125;;const addJob = (obj) =&gt; &#123;  obj.job = &quot;老师&quot;;&#125;;const addAction = (obj) =&gt; &#123;  obj.action = &quot;睡觉&quot;;&#125;;addJob(zhangsan);console.log(zhangsan.job); // 老师addAction(lisi);console.log(lisi.action); // 睡觉\n\n5. 原型模式\n原型允许把一个对象作为蓝图创建另一个对象，新对象继承原对象的属性和方法。\n\n&#123;cmdconst person = &#123;  eat: () =&gt; console.log(&quot;吃饭&quot;),  sleep: () =&gt; console.log(&quot;睡觉&quot;),&#125;;const zhangsan = &#123;  name: &quot;张三&quot;,  age: 18,&#125;;// 将person设置为zhangsan的原型Object.setPrototypeOf(zhangsan, person);zhangsan.eat(); // 吃饭zhangsan.sleep(); // 睡觉\n","categories":["前端","javascript","设计模式"],"tags":["笔记","前端","javascript"]},{"title":"css世界-记录","url":"/741b471ab1bd/css%E4%B8%96%E7%95%8C-%E8%AE%B0%E5%BD%95/","content":"任意高度元素的展开收起动画使用 max-height 配合 transition 实现 ，当 max-height 比设定的 height 大的时候，元素的高度取 height 的值。\n.el &#123;  max-height: 0;  overflow: hidden;  transition: max-height 0.25s;&#125;.el.active &#123;  max-height: 1000px;&#125;\n\n需要注意，虽然 max-height 需要大于 height，但是需要 max-height 的值不能过大，这样会导致过渡动画可能不明显，比如，当前的元素高度是 100 像素，而 max-height 是 1000 像素，动画时间是 250ms，假设动画函数是线性的，则前 225ms 是看不到收起效果的，因为 max-height 从 1000 像素 到 100 像素 变化这段时间，元素不会有区域被隐藏，会给人动画延迟 225ms 的感觉。 所以需要给 max-height 设定一个足够安全（使动画按照预期发生）的值。\n幽灵空白节点在 HTML5 中，内联元素渲染后在页面的表现如同该元素盒子前有一个“空白节点”一样，这个“空白节点”是透明的、不占据宽度且无法通过代码获取，其表现如同文本节点。（非 HTML5 的内联元素不存在该现象）\n规范中实际上对这个“幽灵空白节点”是有提及的，“幽灵空白节点” 实际上也是一个盒子，不过是个假想盒，名叫“strut”，中文直译为“支柱”，是一个存在于每个“行框盒子”前面，同时具有该元素的字体和行高属性的0宽度的内联盒\n层叠上下文准则\n谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index 属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个\n后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素\n\n","categories":["前端","CSS"],"tags":["前端","CSS"]},{"title":"css计数器","url":"/1b3605bb078e/css%E8%AE%A1%E6%95%B0%E5%99%A8/","content":"CSS 可以通过其计数器功能实现不使用 js 在列表前添加序号等操作。\n1. 初始化计数器counter-reset: name number;\n\n\nname: 设定的计数器名称\nnumber：计数器初始值，默认为 0\n\n2. 操作值counter-increment: name number;\n\n\nname: 计数器名称\nnumber: 增加的值，默认为 1，可以设置为 0 和负数\n\n3.获取并显示值content: counter(name, style);\n\n\nname: 计数器名称\nstyle: 计数器样式，见 counter-style_计数器样式\n\n也可使用 counters\ncounters(name, string, style)\n\n\nname: 计数器名称\nstring: 用来定义多个计数器同时使用的连接符\nstyle: 计数器样式，\n\n例 1（使用 counter）&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;style&gt;      body &#123;        counter-reset: section;      &#125;      h2::before &#123;        counter-increment: section;        content: &quot;Section &quot; counter(section) &quot;: &quot;;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h2&gt;标题1&lt;/h2&gt;    &lt;h2&gt;标题2&lt;/h2&gt;    &lt;h2&gt;标题3&lt;/h2&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n\n效果如下\n\n\n\n  \n    \n    \n      body {\n        counter-reset: section;   \n      }\n      h2::before {\n        counter-increment: section;\n        content: \"Section \" counter(section) \": \";\n      }\n    \n  \n  \n    标题1\n    标题2\n    标题3\n  \n\n\n\n例 2（使用 counters）&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;style&gt;      ol &#123;        counter-reset: section;        list-style-type: none;      &#125;      li::before &#123;        counter-increment: section;        content: counters(section, &quot;.&quot;) &quot; &quot;;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;ol&gt;      &lt;li&gt;item&lt;/li&gt;      &lt;li&gt;        item        &lt;ol&gt;          &lt;li&gt;item&lt;/li&gt;          &lt;li&gt;item&lt;/li&gt;          &lt;li&gt;            item            &lt;ol&gt;              &lt;li&gt;item&lt;/li&gt;              &lt;li&gt;item&lt;/li&gt;              &lt;li&gt;item&lt;/li&gt;            &lt;/ol&gt;          &lt;/li&gt;          &lt;li&gt;item&lt;/li&gt;        &lt;/ol&gt;      &lt;/li&gt;      &lt;li&gt;item&lt;/li&gt;      &lt;li&gt;item&lt;/li&gt;    &lt;/ol&gt;    &lt;ol&gt;      &lt;li&gt;item&lt;/li&gt;      &lt;li&gt;item&lt;/li&gt;    &lt;/ol&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n效果如下\n\n\n\n  \n    \n    \n      ol {\n        counter-reset: s2;\n        list-style-type: none;\n      }\n      li::before {\n        counter-increment: s2;\n        content: counters(s2, \".\") \" \";\n      }\n    \n  \n  \n    \n      item\n      \n        item\n        \n          item\n          item\n          \n            item\n            \n              item\n              item\n              item\n            \n          \n          item\n        \n      \n      item\n      item\n    \n    \n      item\n      item\n    \n  \n\n\n\n","categories":["前端","CSS"],"tags":["前端","CSS"]},{"title":"hexo配置aPlayer播放器","url":"/f95cfd58c53a/hexo%E9%85%8D%E7%BD%AEaplayer%E6%92%AD%E6%94%BE%E5%99%A8/","content":"首先安装 hexo-tag-aplayer 插件 npm install hexo-tag-aplayer --save\n然后在主题配置文件 _config.**.yml 文件中添加配置\naplayer:  asset_inject: true  # 自动插入 Aplayer.js 与 Meting.js 资源脚本, 默认开启  meting: true # 启用 metingjs\n之后根据官方文档进行配置即可 hexo-tag-aplayer\n这里主要介绍配置aPlayer全局播放的配置方式\n首先设置 asset_inject 为 false，之后在主题的配置文件中使用 inject 注入aPlayer的dom结构，由于需要全局播放所以需要开启 pjax 功能。注意 pjax 和 aplayer 配置项在同一个配置文件中最好。\naplayer:  asset_inject: false  meting: truepjax:  enable: trueinject:  bottom:    # 注入音乐播放器    - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;&quot; data-server=&quot;&quot; data-type=&quot;&quot; data-fixed=&quot;&quot; data-autoplay=&quot;&quot;&gt; &lt;/div&gt;\naplayer使用的参数如下：\n\n\n\n选项\n默认值\n描述\n\n\n\ndata-id\n必填\n音乐id、播放列表id、相册id、搜索关键字\n\n\nserver\n必填\n音乐数据源：netease（网易云）、tencent（QQ音乐）、kugou、xiaomi、baidu\n\n\ntype\n必填\nsong（音乐）、playlist（播放列表，歌单）、album、search（关键词搜索）\n\n\nfixed\nfalse\n是否开启固定模式\n\n\nmini\nfalse\n是否开启迷你模式\n\n\nloop\nall\n列表循环模式：all,one,none\n\n\norder\nlist\n列表播放模式：list,random\n\n\nautoplay\ntrue\n是否自动播放,根据浏览器规则可能不可用\n\n\nvolume\n0.7\n初始音量，范围为0到1\n\n\npreload\nauto\n预加载模式：none,metadata,auto\n\n\ntheme\n#ad7a86\n主题颜色，支持16进制颜色代码\n\n\nlistmaxheight\n340px\n播放列表最大高度，单位为px\n\n\nmutex\ntrue\n互斥模式，开启后同一时间只能播放一个播放器实例\n\n\nlistfolded\nfalse\n列表折叠状态，默认不折叠\n\n\naPlayer 官方文档：APlayer\n","categories":["hexo"],"tags":["hexo","aPlayer"]},{"title":"微信小程序构建npm","url":"/cbcd0deeb7dd/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%84%E5%BB%BAnpm/","content":"在微信小程序中初始化 npm从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。\n初始化 npm\n在小程序项目根目录下执行 npm init 命令，生成 package.json 文件。\n\n在 package.json 中添加依赖包：\nnpm install --save &lt;package-name&gt;@&lt;version&gt;\n\n\n如果仅需要初始化而暂时不安装依赖，可以在 package.json 目录下创建一个空的 node_modules 目录。\n\n\n安装依赖后设置project.config.json：\n&#123;  &quot;setting&quot;: &#123;    &quot;packNpmManually&quot;: true,    &quot;packNpmRelationList&quot;: [      &#123;        &quot;packageJsonPath&quot;: &quot;./package.json&quot;,        &quot;miniprogramNpmDistDir&quot;: &quot;./&quot;      &#125;    ]  &#125;&#125;\n\n打开”工具”-&gt;”构建 npm”，点击“确定”开始构建。\n\n\n","categories":["前端","微信小程序"],"tags":["npm"]},{"title":"文件上传","url":"/e3d1edfed0ad/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"文件分片上传分片上传主要解决文件过大导致上传时间长的问题，将大文件分割成多个小块进行上传。由于浏览器请求限制，现在浏览器对同一域名的最大请求并发数通常为 6 个（不同浏览器可能限制不同）。\n前端通过Blob.prototype.slice()方法对文件进行分片，然后通过FormData对象将每个分片封装成表单数据。\nasync function onUpload(e) &#123;  if (!e.target.files[0]) return alert(&quot;No file selected&quot;);  const file = e.target.files[0];  const chunkSize = 1024 * 1024 * 5; // 分片大小，这里为5MB  const chunkTotal = Math.ceil(file.size / chunkSize); // 分片数量  /**   * 1. 获取文件hash作为标识   * 2. 创建切片   * 3. 将切片转换为formData   */  const taskPool = formDatas.map(    (formData) =&gt; () =&gt;      fetch(&quot;http://localhost:3000/upload&quot;, &#123;        method: &quot;POST&quot;,        body: formData,      &#125;)  );  /**   * 并发发送请求，并发数为6个   */  await concurRequest(taskPool, 6);&#125;\n\n代码地址\n服务端\n此处服务端使用express框架，接收前端发送的分片文件。\n需要使用multiparty中间件来解析表单数据，并通过文件名来判断是哪个分片。\n本文所用分片文件名格式为 文件hash-分片序号\n\n(req, res) =&gt; &#123;  const form = new multiparty.Form();  // 真实文件保存地址  const uploadDir = &quot;./files&quot;;  // 分片文件缓存地址  const chunkDir = &quot;./cache&quot;;  form.parse(req, async (err, fields, files) =&gt; &#123;    if (err) return res.status(500).send(&quot;Error&quot;);    /**     * 从formData中获取文件信息并存入对应缓存目录     * 当所有分片上传完成，通过文件流合并分片还原原始文件到最终文件目录     * 删除缓存的分片文件     * /  &#125;)&#125;;\n\n代码地址\n可能出现的问题\n在 windows 系统下，系统默认缓存在 C 盘。当服务端程序在非 C 盘分区且进行合并操作时可能出现文件合并失败的问题。本文放弃了文件移动操作，将文件复制到目标目录下，再行清除缓存。\n\n由于使用并发上传，所以可能出现多个分片同时到达服务器的情况，此时直接合并文件会导致出现两个最终文件的情况（最终文件文件名有 hash 或时间戳等随机串），本文采用了文件合并锁的方式来解决这个问题。\n// 设置合并锁const fileMergeLocks = new Set();/** * 处理分片代码 */if (chunkFiles.length === parseInt(chunkTotal)) &#123;  if (fileMergeLocks.has(fileHash)) &#123;    return res.status(200).send(&quot;文件正在合并中,跳过合并操作&quot;);  &#125; else &#123;    // 当前文件没有在合并队列时，将当前文件加入锁列表并开始合并    fileMergeLocks.add(fileHash);    try &#123;      /**       * 文件合并代码       */    &#125; finally &#123;      // 无论文件是否合并成功，都从锁列表中移除      fileMergeLocks.delete(fileHash);    &#125;  &#125;  /**   * 其他操作   */&#125;\n\n","categories":["前端"],"tags":["前端","文件上传"]}]