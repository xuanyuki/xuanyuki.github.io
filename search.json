[{"title":"Antd 组件使用formList时取值为事件数组的问题","url":"/480d78cdfe2c/Antd-%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8formList%E6%97%B6%E5%8F%96%E5%80%BC%E4%B8%BA%E4%BA%8B%E4%BB%B6%E6%95%B0%E7%BB%84%E7%9A%84%E9%97%AE%E9%A2%98/","content":"问题在使用 Antd 的 Form 组件时，使用 formList 来动态生成表单项，但是在取值的时候，发现取到的值是一个事件数组，而不是实际的值。\n&lt;Form form=&#123;form&#125;&gt;  &lt;Form.List name=&quot;importantGuests&quot;&gt;    &#123;(fields, &#123; add, remove &#125;) =&gt; (      &lt;&gt;        &#123;          fields.map((field,index) =&gt;(            &lt;Form.Item name=&#123;[field.name, &#x27;name&#x27;]&#125; key=&#123;field.key&#125;&gt;              &lt;Input /&gt;            &lt;/Form.Item&gt;          ))        &#125;        &lt;div className=&quot;tw-flex tw-cursor-pointer tw-items-center tw-justify-center tw-rounded-[6px] tw-border-[1px] tw-border-dashed tw-border-[#ccc] tw-bg-[#ECECEC] tw-py-[10px] tw-text-[18px] tw-text-[#3D75E9]&quot; onClick=&#123;add&#125;&gt;新增项&lt;/div&gt;      &lt;/&gt;    )&#125;  &lt;/Form.List&gt;&lt;/Form.List&gt;\n\n使用form.getFieldsValue()取得值为：\n分析通过事件中的target属性我们得知，这个事件是新增按钮的点击事件。说明表单被带有点击事件的DOM所影响导致点击事件被Form.List捕获替代了应该传递的值。\n当在Form.List中操作（添加&#x2F;删除项）时，Ant Design 的表单管理机制可能在某些情况下：\n\n事件冒泡没有被正确处理：点击”添加”按钮时，click事件可能通过某种方式被Form.List捕获\n表单数据与事件对象的浅合并：在某些情况下，React的合成事件对象可能被错误地合并到表单数据中\n异步更新导致的竞态条件：add()操作和表单验证可能在时间上重叠，导致临时状态被捕获\n\n解决方案\n使用stopPropagation阻止事件冒泡\n使用e.preventDefault()阻止默认行为\n\n\n\n\n\n","categories":["前端","React","Ant Design","Form"],"tags":["前端","React","Ant Design"]},{"title":"Hello 算法（一）","url":"/c85c77c53426/Hello-%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/","content":"复杂度分析1. 算法效率评估算法效率主要包含两个维度：\n\n时间维度：算法的运行时间\n空间维度：算法运行过程中占用的内存大小\n\n效率评估方法主要分为两种：实际测试、理论估算。\n1.1 实际测试当我们拥有两个解决同一个问题的算法A和算法B，我们可以直接将其在同一台计算机上运行并监控记录它们的运行时间与内存占用情况，从而判断出哪个算法更优。但是这种方式虽然能反映实际情况，但是也会带来一些问题。\n\n在真实计算机环境下，计算机的硬件配置、操作系统、运行的其他进程等都会影响程序的运行时间。\n对算法进行完整测试需要大量资源，随着输入数据的变化算法表现出的效率也不同，因此需要大量的实验去验证。\n\n1.2 理论估算由于实际测试具有较大的局限性，我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。复杂度分析能够体现算法运行所需的时间和空间资源与输入数据规模之间的关系。它描述了随着输入数据规模的增加，算法执行所需时间和空间的增长趋势。复杂度分析克服了实际测试方法的弊端，体现在以下几个方面。\n\n它无需实际运行代码，更加绿色节能。\n它独立于测试环境，分析结果适用于所有运行平台。\n它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。\n\n2. 迭代与递归2.1 迭代迭代是重复执行一个任务的过程，在每次迭代中，程序需要满足一定的条件才能重复执行。\nfor 循环for 循环是最常见的迭代形式，适用于预先知道需要迭代的次数时使用。现在我们实现一个求和函数：\nfunction sum(n) &#123;  let res = 0;  for (let i = 1; i &lt;= n; i++) &#123;    res += i;  &#125;  return res;&#125;\n\n以下是该求和函数的流程图：\ngraph TD;\nA(开始) --&gt; B[初始化 i=1];\nsubgraph 循环\n  B--&gt; c&#123;i&lt;=n&#125; ;\n  c--真--&gt; D[执行任务] ;\n  D--&gt; E[执行 i+=1];\n  E --&gt; c;\nend\nc --假--&gt; F[结束];\n\n\n此求和函数的操作数量与输入数据大小 成正比，或者说成“线性关系”。实际上，时间复杂度描述的就是这个“线性关系”。相关内容将会在下一节中详细介绍。\nwhile 循环while 循环适用于预先不知道需要迭代的次数，但知道迭代结束条件的情况。在 while 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。现在我们实现一个求和函数：\nfunction sum(n) &#123;  let res = 0;  let i = 1;  while (i &lt;= n) &#123;    res += i;    i++;  &#125;  return res;&#125;\n\n嵌套循环嵌套循环指在一个循环中包含另一个循环。以 for 循环为例：\nfunction nestedForLoop(n) &#123;  let res = &quot;&quot;;  for (let i = 1; i &lt;= n; i++) &#123;    for (let j = 1; j &lt;= n; j++) &#123;      res += `($&#123;i&#125;, $&#123;j&#125;), `;    &#125;  &#125;  return res;&#125;\n\n以下是该函数的流程图：\ngraph TD;\nA(开始) --&gt; B[初始化 i=1];\nsubgraph 外层循环\n  B --&gt; C&#123;i&lt;=n&#125;;\n  C --真--&gt; D[执行任务];\n  I[执行 i+=1] --&gt; C;\n  C --假--&gt; END2[结束];\nend\nsubgraph 内层循环\n  D --&gt; E[初始化 j = 1];\n  E --&gt; F&#123;j&lt;=n&#125;;\n  F --真--&gt; G[执行任务];\n  G --&gt; H[执行 j+=1];\n  H --&gt; F;\n  F --假--&gt; END[结束];\n  END --&gt; I\nend\n\n此嵌套循环的操作数量与输入数据大小成“平方”关系。且当我们每一次添加一个嵌套循环时，时间复杂度会呈指数增长。\n2.2 递归递归主要通过函数调用自身来解决问题，它主要包含两个阶段：\n\n递：函数不断深入调用自身，直到达成终止条件。\n归：触发终止条件后，程序从深层开始将结果汇聚。\n\n在实现上，主要包含三个要素：\n\n终止条件\n递归调用\n返回结果\n\n接下来使用递归来完成求和函数：\nfunction sum(n) &#123;  if (n === 1) return 1;  const res = sum(n - 1);  return res + n;&#125;\n\n从计算角度看，递归与循环都可以得到同样的结果，但是他们的实际执行过程截然不同。\n\n迭代：“自下而上”，从基础步骤出发，不断地循环这个过程最后得出结果\n递归：“自上而下”，从最终目标出发，不断地将问题拆解为更小的子问题，直到达到终止条件\n\n调用栈由于函数在调用时，系统会单独为它分配一块内存空间，直到函数结束才会释放，所以当递归触发结束条件前系统会不断为它分配内存空间，这些内存空间被称为调用栈（call stack）。所以递归会比迭代更加的耗费内存空间，但是递归的时间效率通常比迭代更低。在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。\n尾递归尾递归是一种特殊的递归形式，如果函数在返回前的最后一步进行递归调用，则该函数可以被编译器或解释器优化，使其的空间效率与迭代相当。这种情况被称为尾递归。\n以求和函数为例：\nfunction sun(n, res) &#123;  if (n === 0) return res;  return sum(n - 1, res + n);&#125;\n\n递归树在处理“分治”类型的问题时，递归往往比迭代更加直观，以斐波那契数列为例：\nfunction fib(n) &#123;  if (n === 1 || n === 2) return 1;  const res = fib(n - 1) + fib(n - 2);  return res;&#125;\n\n现在我们在函数递归中每次调用了两个函数，如此不断递归，最终会形成一棵递归树，如下所示：\ngraph TD;\n  A(&quot;f(n)&quot;)\n  B(&quot;f(n-1)&quot;)\n  C(&quot;f(n-2)&quot;)\n  A --&gt; B\n  A --&gt; C\n  B --&gt; D(&quot;f(n-2)&quot;)\n  B --&gt; E(&quot;f(n-3)&quot;)\n  C --&gt; F(&quot;f(n-3)&quot;)\n  C --&gt; G(&quot;f(n-4)&quot;)\n  D --&gt; H(&quot;f(n-3)&quot;)\n  D --&gt; I(&quot;f(n-4)&quot;)\n  E --&gt; J(&quot;f(n-4)&quot;)\n  E --&gt; K(&quot;f(n-5)&quot;)\n  F --&gt; L(&quot;f(n-4)&quot;)\n  F --&gt; M(&quot;f(n-5)&quot;)\n  G --&gt; N(&quot;f(n-5)&quot;)\n  G --&gt; O(&quot;f(n-6)&quot;)\n\n2.3 对比\n\n\n\n迭代\n递归\n\n\n\n实现方式\n循环\n函数自调用\n\n\n时间效率\n时间效率较高，没有因为额外函数调用产生的开销\n每次递归都会产生开销\n\n\n内存使用\n固定大小\n根据递归的次数而定，次数越多内存消耗越大\n\n\n3. 时间复杂度现在我们知道了运行时间可以直观的反映算法的效率，而我们如何去预估代码的运行时间呢？\n现在假设加法操作需要 1 单位时间，乘法需要 10 单位时间，而输出需要 5 单位时间，以以下代码为例：\nfunction algorithm(n) &#123;  let a = 2; // 1  a = a + 1; // 1  a = a * 2; // 10  for (let i = 0; i &lt; n; i++) &#123;    // 1    console.log(i); // 5  &#125;&#125;\n\n根据以上代码我们算得：\n\n加法操作：1 次\n乘法操作：1 次\n输出操作：n 次\n循环操作中的加法操作：n 次\n\n即：$1 + 1 + 10 + 5n + n &#x3D; 6n + 12$\n3.1 统计时间增长趋势时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势。以下面代码为例：\n// 算法 A 的时间复杂度：常数阶function algorithm_A(n) &#123;  console.log(0);&#125;// 算法 B 的时间复杂度：线性阶function algorithm_B(n) &#123;  for (let i = 0; i &lt; n; i++) &#123;    console.log(0);  &#125;&#125;// 算法 C 的时间复杂度：常数阶function algorithm_C(n) &#123;  for (let i = 0; i &lt; 1000000; i++) &#123;    console.log(0);  &#125;&#125;\n\n\n算法 A 中无论 n 为何值，算法 A 的运行时间都是 1，所以该算法的时间复杂度为“常数阶”\n算法 B 中的打印操作根据 n 的变化而呈线性变化，且运行时间根据 n 的变化而线性变化。所以该算法的时间复杂度为“线性阶”\n算法 C 中无论 n 为何值，算法 C 的运行时间都是 1000000，所以该算法的时间复杂度依然为“常数阶”\n\n\n\n\n\n  if (window.eChartecharts8978ResizeHandler) {\n    window.removeEventListener(\"resize\", eChartecharts8978ResizeHandler);\n  }\n  var optionecharts8978 = {\n\"title\": {\n\"text\": \"算法运行时间\",\n\"left\": \"center\",\n\"textStyle\": {\n\"fontSize\": 16,\n\"fontWeight\": \"bold\"\n}\n},\n\"tooltip\": {\n\"show\":false\n},\n\"legend\": {\n\"data\": [\"算法 C - 常数阶\", \"算法 B - 线性阶\", \"算法 A - 常数阶\"],\n\"top\": \"8%\"\n},\n\"grid\": {\n\"left\": \"10%\",\n\"right\": \"10%\",\n\"bottom\": \"15%\",\n\"top\": \"20%\"\n},\n\"xAxis\": {\n\"name\": \"输入数据大小 n\",\n\"nameLocation\": \"middle\",\n\"nameGap\": 30,\n\"type\": \"value\",\n\"min\": 0,\n\"max\": 9,\n\"interval\": 1,\n\"axisLine\": {\n\"show\": true\n},\n\"axisTick\": {\n\"show\": true\n}\n},\n\"yAxis\": {\n\"name\": \"算法运行时间\",\n\"type\": \"value\",\n\"min\": 0,\n\"max\": 9,\n\"interval\": 1,\n\"axisLine\": {\n\"show\": true\n},\n\"axisTick\": {\n\"show\": true\n}\n},\n\"series\": [\n{\n\"name\": \"算法 C - 常数阶\",\n\"type\": \"line\",\n\"data\": [[0, 1], [9, 1]],\n\"lineStyle\": {\n\"color\": \"#5470c6\",\n\"width\": 2\n},\n\"symbol\": \"none\"\n},\n{\n\"name\": \"算法 B - 线性阶\",\n\"type\": \"line\",\n\"data\": [[0, 0], [9, 9]],\n\"lineStyle\": {\n\"color\": \"#91cc75\",\n\"width\": 2\n},\n\"symbol\": \"none\"\n},\n{\n\"name\": \"算法 A - 常数阶\",\n\"type\": \"line\",\n\"data\": [[0, 2], [9, 2]],\n\"lineStyle\": {\n\"color\": \"#fac858\",\n\"width\": 2\n},\n\"symbol\": \"none\"\n}\n]\n};\n  if (window.echarts !== undefined) {\n    var eChartecharts8978 = echarts.init(document.getElementById('echarts8978'));\n    eChartecharts8978.setOption(optionecharts8978);\n    var eChartecharts8978ResizeHandler = function() {\n      eChartecharts8978.resize();\n    };\n    window.addEventListener(\"resize\", eChartecharts8978ResizeHandler);\n  }\n\n\n算法 A、B 和 C 的时间增长趋势\n\n时间复杂度分析的特点：\n\n时间复杂度能够有效评估算法效率。当输入数据足够大，常数阶的算法一定优于线性阶。\n时间复杂度的推算方法更简便。不需要考虑运行环境，将所有算法统一以“单位时间”为基准，将时间统计转为数量统计。\n时间复杂度也存在一定的局限性。可能会出现两个不同算法的时间复杂度相同但实际运行时间不同；算法 A 比算法 B 时间复杂度高，但是输入数据很小时出现的算法 A 比算法 B 实际运行时间短的问题。\n\n3.2 函数渐进上界给定一个输入为 n 的函数：\nfunction algorithm(n) &#123;  let res = 0;  res += 1;  res *= 2;  for (let i = 0; i &lt; n; i++) &#123;    console.log(i);  &#125;&#125;\n\n该函数的操作数量为：$3+2n$由于该函数是一次函数，所以该算法的运行时间根据输入n呈线性增长，所以它的复杂度为线性阶。现在我们将线性阶的时间复杂度记为$O(n)$,其中$O$表示函数的渐进上界。\n\n函数渐近上界\n若存在正实数 $c$ 和实数$n_0$，使所有对于$n>n_0$时，均有，$T(n) \\leqslant c \\cdot f(n)$，则可认为$f(n)$给出了$T(n)$的一个渐进上界，标记为$T(n) = O(f(n))$。\n3.3 推算方法3.3.1 统计操作数量\n忽略$T(n)$中的常数。常数不影响时间复杂度。\n省略所有系数。如$2n$和$5n+1$的时间复杂度相同，都记为$n$次。\n循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积。如：$3n^2 + 2n$的时间复杂度为$O(n^2)$。\n\nfunction algorithm(n) &#123;  let a = 1; // 常数阶 记为0  a = a + n; // 常数阶 记为0  // 线性阶 记为n  for (let i = 0; i &lt; 5 * n + 1; i++) &#123;    console.log(0);  &#125;  // 嵌套循环 记为n*n  for (let i = 0; i &lt; 2 * n; i++) &#123;    for (let j = 0; j &lt; n + 1; j++) &#123;      console.log(0);    &#125;  &#125;&#125;\n\n根据以上方法统计出该程序的时间复杂度为：$O(n^2)$。完整统计：$T(n)&#x3D;2n(n+1)+(5n+1)+2$$&#x3D; 2n^2 + 7n + 3$根据方法省略统计：$T(n)&#x3D;n^2+n$\n3.3.2 判断渐近上界时间复杂度由$T(n)$中的最高阶的项决定。因为在n趋向于无穷大时，最高阶的项发挥主导作用，可以忽略其他项的影响。\n不同操作数量对应的时间复杂度：\n\n\n\n操作数量$T(n)$\n时间复杂度$O(f(n))$\n\n\n\n10000\n$O(1)$\n\n\n$3n+2$\n$O(n)$\n\n\n$2n^2+3n+2$\n$O(n^2)$\n\n\n$n^3+10000n^2$\n$O(n^3)$\n\n\n$2^n+10000n^10000$\n$O(2^n)$\n\n\n3.4 常见时间复杂度类型设输入数据为n，场景的时间复杂度如下：\n$O(1) &lt; O(\\log n) &lt; O(n)&lt;O(n \\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!)$常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt;br 平方阶 &lt;br 指数阶 &lt;br 阶乘阶\n\n常数阶$O(1)$：常数阶的操作数量与输入数据大小 $n$ 无关，即不随着 $n$ 的变化而变化。\n线性阶$O(n)$：线性阶的操作数量相对于输入数据大小 $n$ 以线性级别增长。\n平方阶$O(n^2)$：平方阶的操作数量相对于输入数据大小 $n$ 以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为 $O(n)$ ，因此总体的时间复杂度为：$O(n^2)$。\n指数阶$(O(2^n))$：生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推，分裂 $n$ 轮后有 $2^n$ 个细胞。\n对数阶$O(log n)$：与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。\n线性对数阶$O(n log n)$：线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 $O(log n)$ 和 $O(n)$。\n阶乘阶$O(n!)$：阶乘阶对应数学上的“全排列”问题。给定 $n$ 个互不重复的元素，求其所有可能的排列方案，方案数量为：$n! &#x3D; n \\times (n-1) \\times (n-2) \\times … \\times 2 \\times 1$。\n\n3.5 最差、最佳、平均时间复杂度算法的时间效率往往不是固定的，而是与输入数据的分布有关。假如一个数组长度为 n，且最后一个元素为 1 ，当我们需要找到值为 1 的元素时，需要完整遍历整个数组，这时该算法就达到最差时间复杂度，即：$O(n)$。反之，当数组中的第一个元素为 1 时，我们只需要遍历一次就能找到，这时该算法就达到最佳时间复杂度，即：$\\Omega(1)$。“最差时间复杂度”对应函数渐进上界，使用大$O$表示；“最佳时间复杂度”则对应函数渐进下界，使用大$\\Omega$表示。相比之下，平均时间复杂度可以体现算法在随机输入数据下的运行效率，则使用大$\\Theta$表示。\n4. 空间复杂度空间复杂度用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。\n4.1 算法相关空间算法在运行过程中使用的内存空间主要包括以下几种。\n\n输入空间：输入的数据\n暂存空间：算法运行过程中使用的临时变量\n输出空间：输出的数据\n\n一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。\n暂存空间可以分为三部分：\n\n暂存数据：用于保存算法运行过程中的数据\n栈帧空间：用于保存算法函数调用时的上下文数据\n指令空间：用于保存算法运行过程中的指令，实际可以忽略不计\n\n4.2 推算方法空间复杂度的推算方法与时间复杂度大致相同，只需将“操作数量”转为“占用内存空间”即可。与时间复杂度不同，对于空间复杂度通常只关注“最差空间复杂度”，因为我们需要确保算法在运行过程中不会出现内存不足的情况。在递归函数中，需要注意统计栈帧空间。\n4.3 常见空间复杂度类型\n\n\n空间复杂度\n算法场景\n\n\n\n$O(1)$\n常数阶\n\n\n$O(\\log n)$\n对数阶\n\n\n$O(n)$\n线性阶\n\n\n$O(n^2)$\n平方阶\n\n\n$O(2^n)$\n指数阶\n\n\n\n常数阶$O(1)$：常数阶的空间复杂度表示算法运行过程中占用的内存空间与输入数据大小 $n$ 无关，即不随着 $n$ 的变化而变化。在循环内部初始化的变量或者调用函数占用的内存，在下一次循环时会释放，所以不需要考虑。\n线性阶$O(n)$：线性阶常见于元素数量与输入数据大小 $n$ 成正比的场景，如：数组、链表、队列、栈等。\n平方阶$O(n^2)$：平方阶常见于元素数量与输入数据大小 $n$ 成平方关系的场景，如：二维数组、矩阵等。\n指数阶$O(2^n)$：指数阶常见于二叉树。\n对数阶$O(\\log n)$：对数阶常见于分治，如：二分查找、快速排序、归并排序等。\n\n\n\n\n\n","categories":["算法"],"tags":["算法","笔记","Hello 算法"]},{"title":"JavaScript忍者秘籍（一）","url":"/ebaa4fc9c186/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%B8%80%EF%BC%89/","content":"web应用运行时的构建过程生命周期\n从用户在浏览器地址栏输入URL或者点击链接开始，浏览器向服务器请求了由HTML、CSS、JavaScript组成的资源。当浏览器接收到这些资源，我们的web应用正式开启它的生命周期。\n\n\n执行步骤如下：\n\n页面构建——浏览器解析HTML，构建DOM树；解析CSS，构建CSSOM树，解析JavaScript，执行代码。\n事件处理——浏览器等待用户交互并在事件发生时执行事件处理程序。\n\n当用户离开或关闭页面时，该web应用的生命周期结束。\n页面构建当web应用被请求完成但可以被展示或交互之前，浏览器需要根据服务器响应的HTML、CSS和JavaScript完成对页面的构建：\n\n解析HTML，构建DOM树\n执行JavaScript——在浏览器解析HTML的过程中，如果遇到JavaScript脚本标签（&lt;script&gt;），浏览器会停止构建DOM树，执行该段代码；随后继续构建DOM树。\n\n事件处理概览由于浏览器的事件处理机制为单线程执行模型，为实现它，浏览器使用了任务队列机制，所有已生成的事件（无论是用户生成的，例如鼠标移动或键盘点击，还是服务器生成的，例如Ajax事件）都会放在同一个事件队列中，以它们被浏览器检测到的顺序排列。\n\n浏览器检查事件队列头；\n如果浏览器没有在队列中检测到事件，则继续检查；\n如果浏览器在队列头中检测到了事件，则取出该事件并执行相应的事件处理器（如果存在）。在这个过程中，余下的事件在事件队列中耐心等待，直到轮到它们被处理\n\n\n事件可能会以难以预计的时间和顺序发生，我们对事件的处理，以及处理函数的调用是异步的。如下类型的事件会在其他类型事件中发生：\n\n浏览器事件，例如当页面加载完成后或无法加载时；\n网络事件，例如来自服务器的响应（Ajax事件和服务器端事件）；\n用户事件，例如鼠标单击、鼠标移动和键盘事件；\n计时器事件，当timeout时间到期或又触发了一次时间间隔。\n\n注册事件处理器在JavaScript中，我们可以通过两种方式注册事件处理器：\n\n将事件处理函数赋给特定属性\n调用addEventListener()方法\n\n处理事件事件处理背后的主要思想是：当事件发生时，浏览器调用相应的事件处理器。由于单线程执行模型，所以浏览器同一时刻只能处理一个事件，且处理顺序是事件生成的顺序。任何后面的事件都只能在当前事件处理器完全结束执行后才能被处理！\n\n\n\n\n","categories":["前端","javascript"],"tags":["前端","笔记","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript忍者秘籍（三）","url":"/40ebbe81ddb2/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%B8%89%EF%BC%89/","content":"生成器1. 使用生成器函数function* myGenerator() &#123;  yield 1;  yield 2;&#125;\n\n创建一个生成器很简单，只需要在函数声明中使用一个星号*。这样就可以在生成器函数中使用yield关键字了。\nfor (const value of myGenerator()) &#123;  console.log(value); // 1 2&#125;\n\nfor-of 的执行结果如注释所示，当我们使用生成器时并没有使用return关键字。实际上调用生成器并不会执行生成器函数，而是会创建一个迭代器对象。\n2. 通过迭代器对象控制生成器/** 定义了一个生成器函数 */function* WeaponGenerator() &#123;  yield &quot;Katana&quot;;  yield &quot;Wakizashi&quot;;&#125;const weaponsIterator = WeaponGenerator(); // 创建迭代器对象const result1 = weaponsIterator.next(); // &#123; value: &quot;Katana&quot;, done: false &#125;const result2 = weaponsIterator.next(); // &#123; value: &quot;Wakizashi&quot;, done: false &#125;const result3 = weaponsIterator.next(); // &#123; value: undefined, done: true &#125;\n\n在调用生成器后，我们得到了一个迭代器对象。通过调用next()方法可以逐个访问生成器的值。每次调用next()方法，都会返回一个对象，其中封装了结果值和一个指示完成的指示器。\n每当生成一个当前值后，生成器就会非阻塞地挂起执行，随后耐心等待下一次值请求的到达。\n在以上代码中，由于第三次调用next()方法时，生成器已经无法再生成值了，因此返回了一个done: true且value: undefined的对象。\n跟在函数中调用函数一样，我们可以在生成器中调用另一个生成器：\nfunction* WeaponGenerator() &#123;  yield &quot;Katana&quot;;  yield* WeaponGenerator2(); // 委托给另一个生成器  yield &quot;Wakizashi&quot;;&#125;function* WeaponGenerator2() &#123;  yield &quot;Shuriken&quot;;  yield &quot;Kunai&quot;;&#125;for (const value of WeaponGenerator()) &#123;  console.log(value);&#125;\n\n执行上述代码会输出 &quot;Katana&quot;、&quot;Shuriken&quot;、&quot;Kunai&quot;和&quot;Wakizashi&quot;。因为在迭代器上使用 yield*操作符，程序会跳转到另外一个生成器上执行。\n3. 使用生成器使用生成器生成 idfunction* idGenerator() &#123;  let id = 0;  while (true) &#123;    yield id++;  &#125;&#125;const iter = idGenerator();console.log(iter.next().value); // 0console.log(iter.next().value); // 1console.log(iter.next().value); // 2\n\n使用生成器遍历 DOM 树&lt;div id=&quot;subTree&quot;&gt;  &lt;form&gt;    &lt;input type=&quot;text&quot; /&gt;  &lt;/form&gt;  &lt;p&gt;Paragraph&lt;/p&gt;  &lt;span&gt;Span&lt;/span&gt;&lt;/div&gt;&lt;script&gt;  function* domTreeGenerator(node) &#123;    yield node;    for (const child of node.children) &#123;      yield* domTreeGenerator(child); // 委托给该节点的子节点生成器      node = node.nextElementSibling; // 将当前节点指向下一个兄弟节点    &#125;  &#125;  const subTree = document.getElementById(&quot;subTree&quot;);  for (const node of domTreeGenerator(subTree)) &#123;    console.log(node.nodeName);  &#125;&lt;/script&gt;\n\n4. 与生成器交互通过生成器函数参数发送值function* myGenerator(action) &#123;  const result = yield action;  yield result;&#125;const iter = myGenerator(&quot;Hello&quot;);const r1 = iter.next(); // &#123; value: &quot;Hello&quot;, done: false &#125;const r2 = iter.next(&quot;World&quot;); // &#123; value: &quot;World&quot;, done: false &#125;\n\n如果在r2中没有传入值，那么结果将是&#123;value: undefined, done: false&#125;。\n通过next方法发送值除了在第一次调用生成器的时候向生成器提供数据，我们还能通过next方法向生成器传入参数。在这个过程中，我们把生成器函数从挂起状态恢复到了执行状态。生成器把这个传入的值用于整个yield表达式（生成器当前挂起的表达式）的值。\n5. 生成器的内部构成一个生成器的工作流程如下：\n\n挂起开始——创建了一个生成器后，它最先以这种状态开始。其中的任何代码都未执行。\n执行——生成器中的代码执行的状态。执行要么是刚开始，要么是从上次挂起的时候继续的。当生成器对应的迭代器调用了next方法，并且当前存在可执行的代码时，生成器都会转移到这个状态。\n挂起让渡——当生成器在执行过程中遇到了一个yield表达式，它会创建一个包含着返回值的新对象，随后再挂起执行。生成器在这个状态暂停并等待继续执行。\n完成——在生成器执行期间，如果代码执行到return语句或者全部代码执行完毕，生成器就进入该状态。\n\n\n\n\n\n\n","categories":["前端","javascript"],"tags":["前端","笔记","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript忍者秘籍（二）","url":"/de0931cb981b/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"闭包和作用域\n闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。\n\n使用闭包1. 封装私有变量function n()&#123;  let count = 0;  this.getCount = function()&#123;    return count;  &#125;  this.countPlus = function()&#123;    count++;  &#125;&#125;const n1 = new n();n1.countPlus();console.log(n1.count); // undefined 无法直接访问到count变量console.log(n1.getCount()); // 1 通过闭包访问到count变量const n2 = new n();console.log(n2.getCount()); // 0 n1和n2是两个独立的实例，互不影响\n\n在构造器 n 中，我们定义了一个 count 变量来保存状态，由于 count 变量是在构造器内部定义的，因此外部无法直接访问到它。但是通过闭包的方式，我们可以通过 getCount() 和 countPlus() 方法来间接地操作这个私有变量。而像 getCount() 这中只读访问的方法被称为 getter 方法，而像 countPlus() 这样仅修改私有变量的方法被称为 setter 方法。\n2. 回调函数\n回调函数指的是需要在将来不确定的某一时刻异步调用的函数。通常，在这种回调函数中，我们经常需要频繁地访问外部数据。\n\n&lt;div id=&quot;box1&quot;&gt;First Box&lt;/div&gt;&lt;script&gt;  function animate(element)&#123;    const el = document.getElementById(element);    let tick = 0;    let timer = setInterval(function()&#123;      if(tick &lt; 100)&#123;        el.style.left = el.style.top = `$&#123;tick&#125;px`;        tick++;      &#125; else &#123;        clearInterval(timer);      &#125;    &#125;, 10)  &#125;  animate(&#x27;box1&#x27;);&lt;/script&gt;\n\n\n\n  \n    First Box\n    \n      function animate(element){\n        const el = document.getElementById(element);\n        let tick = 0;\n        let timer = setInterval(function(){\n          if(tick < 100){\n            el.style.marginLeft = `${tick}px`;\n            tick++;\n          } else {\n            clearInterval(timer);\n          }\n        }, 10)\n      }\n      animate('box1')\n    \n  \n\n\n\n\n闭包内的函数不仅可以在创建的时刻访问这些变量，而且当闭包内部的函数执行时，还可以更新这些变量的值。闭包不是在创建的那一时刻的状态的快照，而是一个真实的状态封装，只要闭包存在，就可以对变量进行修改。\n\njs的变量类型在词法环境中注册标识符const first = &#x27;first&#x27;;check(first)function check(val)&#123;  console.log(val);&#125;\n由以上代码可以看出：JavaScript对于在哪儿定义函数并不挑剔。在调用函数之前或之后声明函数均可。\n注册标识符的过程\n\n如果是创建一个函数环境，那么创建形参及函数参数的默认值。如果是非函数环境，将跳过此步骤。\n如果是创建全局或函数环境，就扫描当前代码进行函数声明（不会扫描其他函数的函数体），但是不会扫描函数表达式或箭头函数。对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上。若该标识符已经存在，那么该标识符的值将被重写。如果是块级作用域，将跳过此步骤。\n扫描当前代码，查找其中的变量声明。先去查找当前函数以及其他函数之外定义的 var 变量，再去寻找所有在其他函数或代码块之外定义的 let 和 const 变量。在块级环境中仅查找当前块中定义的 let 和 const 变量。对于找到的每个变量声明，在当前环境中创建该变量的标识符，并将其初始化为 undefined，若标识符已存在则保留原有值。\n\ngraph TD;\n   A&#123;当前是否为函数环境？&#125;\n   A --&gt; |是|B(创建函数的参数对象arguments和形参)\n   A --&gt; |否|C&#123;当前环境是全局环境或函数环境？&#125;\n   B --&gt; C\n   C --&gt; |是|D(注册其他函数外的函数声明)\n   C --&gt; |否|E&#123;当前环境是否为块级作用域&#125;\n   D --&gt; E\n   E --&gt; |是|F(注册当前块内的let和const变量)\n   E --&gt; |否|G(注册函数作用域之外的var变量以及在其他函数或代码块之外定义的let和const变量)\n\n闭包的工作原理私有变量现在我们使用前文的例子再次模拟私有变量。\nfunction n()&#123;  let count = 0;  this.getCount = function()&#123;    return count;  &#125;  this.countPlus = function()&#123;    count++;  &#125;&#125;const n1 = new n();n1.countPlus();console.log(n1.count); // undefined 无法直接访问到count变量console.log(n1.getCount()); // 1 通过闭包访问到count变量const n2 = new n();console.log(n2.getCount()); // 0 n1和n2是两个独立的实例，互不影响\n\njavaScript引擎在通过 new 关键字创建 n 函数时，会创建一个新的词法环境，每个词法环境都会包含一份构造函数 n 的局部变量。由于我们在 n 函数中定义了 getCount 和 countPlus 函数，所以这些函数均包含 n 函数的词法环境。\n因为 getCount 和 countPlus 函数是在 n 中新创建的方法（可以通过this关键字访问）。所以可以在 n 函数的外部访问到这些函数，此时就创建了一个包含 count 变量的闭包。\n回调函数这次我们改造前文回调函数\n&lt;div id=&quot;box1&quot;&gt;First Box&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt;second Box&lt;/div&gt;&lt;script&gt;  function animate(element)&#123;    const el = document.getElementById(element);    let tick = 0;    let timer = setInterval(function()&#123;      if(tick &lt; 100)&#123;        el.style.left = el.style.top = `$&#123;tick&#125;px`;        tick++;      &#125; else &#123;        clearInterval(timer);      &#125;    &#125;, 10)  &#125;  animate(&#x27;box1&#x27;);  animate(&#x27;box2&#x27;);&lt;/script&gt;\n在每次调用 animate 函数时，都会创建一个新的词法环境，该词法环境包含了动画所需的变量。只要有一个通过闭包访问这些变量的函数存在，那么这些变量就不会被销毁。即在以上代码中，setInterval 的回调函数会一直存在，直到调用 clearInterval 方法。\n总结\n通过闭包可以访问闭包创建时所处词法环境中的所有变量，通过这种方式，即使创建函数时所处的作用域已经消失，我们仍然可以访问到这些变量。\n可以通过闭包来实现以下功能：\n通过构造函数内的变量以及构造方法来模拟私有变量\n处理回调函数，简化代码\n\n\n闭包是JavaScript作用域规则的副作用。当函数创建时所在的作用域消失后，仍然能够调用函数。\nJavaScript引擎通过词法环境跟踪标识符（俗称作用域）。\nJavaScript引擎通过执行上下文栈（调用栈）跟踪函数的执行。每次调用函数时，都会创建新的函数执行上下文，并推入调用栈顶端。当函数执行完成后，对应的执行上下文将从调用栈中推出（在js代码执行时默认会创建一个全局的执行上下文）。\n\n\n\n\n\n","categories":["前端","javascript"],"tags":["前端","笔记","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript忍者秘籍（五）","url":"/1d049a349d75/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E4%BA%94%EF%BC%89/","content":"事件事件循环\n事件循环不仅仅包含事件队列，而是具有至少两个队列，除了事件，还要保持浏览器执行的其他操作。这些操作被称为任务，并且分为两类：宏任务（或通常称为任务）和微任务。\n宏任务的例子很多，包括创建主文档对象、解析HTML、执行主线（或全局）JavaScript代码，更改当前URL以及各种事件，如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，宏任务代表一个个离散的、独立工作单元。运行完任务后，浏览器可以继续其他调度，如重新渲染页面的UI或执行垃圾回收。\n而微任务是更小的任务。微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。微任务的案例包括promise回调函数、DOM发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使应用程序的状态不连续。\n\n事件循环基于两个基本原则：\n\n一次处理一个任务。\n一个任务开始后直到运行完成，不会被其他任务中断。\n\n\n在每一次迭代中，事件循环会首先检测宏任务队列，如果有宏任务再等待执行，则开始执行宏任务，当该任务执行完毕或宏任务队列为空时，事件循环会检测微任务队列。如果有微任务等待执行，则执行所有可用的微任务。\n\n每次迭代时仅执行一个宏任务，但会执行所有的微任务。\n\n当微任务队列为空时，事件循环会检查是否需要更新UI渲染，完成后，事件循环会再次回到宏任务队列执行下一次迭代。\n至此：\n\n任务队列是独立于事件循环的，且任务队列的添加行为也独立于事件循环。\n由于JavaScript是单线程的，所以当一个任务正在执行时不会被其他任何任务打断，除非浏览器决定中止该任务（任务执行时间过长或者任务占用内存过大）。\n所有微任务都会在下一次渲染前完成，因为它们的目标是在渲染前更新应用程序状态。\n浏览器通常会尝试每秒渲染60次页面，以达到每秒60帧（60 fps）的速度。这意味着浏览器会尝试在16ms内渲染一帧。理想情况下，单个任务和该任务附属的所有微任务，都应在16ms内完成。\n\n\n\n\n\n","categories":["前端","javascript"],"tags":["前端","笔记","javascript","JavaScript忍者秘籍"]},{"title":"JavaScript设计模式","url":"/4fbd70990c3a/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"\n设计模式原则：\n\nS – Single Responsibility Principle 单一职责原则\n一个程序只做好一件事\n如果功能过于复杂就拆分开，每个部分保持独立\n\n\nO – OpenClosed Principle 开放&#x2F;封闭原则\n对扩展开放，对修改封闭\n增加需求时，扩展新代码，而非修改已有代码\n\n\nL – Liskov Substitution Principle 里氏替换原则\n子类能覆盖父类\n父类能出现的地方子类就能出现\n\n\nI – Interface Segregation Principle 接口隔离原则\n保持接口的单一独立\n类似单一职责原则，这里更关注接口\n\n\nD – Dependency Inversion Principle 依赖倒转原则\n面向接口编程，依赖于抽象而不依赖于具体\n使用方只关注接口而不关注具体类的实现\n\n\n\n\n1. 单例模式\n单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n1.1 实现function Singleton(name) &#123;  this.name = name;  this.instance = null;&#125;Singleton.prototype.getName = function () &#123;  return this.name;&#125;;Singleton.getInstance = function (name) &#123;  if (!this.instance) &#123;    this.instance = new Singleton(name);  &#125;  return this.instance;&#125;;const a = Singleton.getInstance(&quot;a&quot;);const b = Singleton.getInstance(&quot;b&quot;);console.log(a === b); // true\n\n如以上代码，无论何时访问Singleton.getInstance()，都会返回同一个实例。\n1.2 使用代理实现class CreateDiv &#123;  html = null;  constructor(html) &#123;    this.html = html;  &#125;  init() &#123;    const div = document.createElement(&quot;div&quot;);    div.innerHTML = this.html;    document.body.appendChild(div);  &#125;&#125;/** 代理类 */const ProxySingletonCreateDiv = (function () &#123;  let instance = null;  return class &#123;    constructor(html) &#123;      if (!instance) &#123;        instance = new CreateDiv(html);      &#125;      return instance;    &#125;  &#125;;&#125;)();const a = new ProxySingletonCreateDiv(&quot;sven1&quot;);const b = new ProxySingletonCreateDiv(&quot;sven2&quot;);console.log(a === b); // true\n\n2. 工厂模式\n工厂模式提供一个创建对象的接口，通过这个接口可以创建不同的对象。可以通过类和工厂函数实现。\n\n2.1 使用类实现class Person &#123;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  say() &#123;    console.log(`$&#123;this.name&#125; say: &#x27;Hello!&#x27;`);  &#125;&#125;const zhangsan = new Person(&quot;张三&quot;, 18);console.log(zhangsan.name); // 张三\n\n2.2 使用工厂函数实现function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;Person.prototype.say = function () &#123;  console.log(`$&#123;this.name&#125; say: &#x27;Hello!&#x27;`);&#125;;const zhangsan = new Person(&quot;张三&quot;, 18);console.log(zhangsan.name); // 张三\n\n3. 抽象工厂模式\n抽象工厂通过特定逻辑调用工厂，通过工厂返回最终对象。\n\nclass Apple &#123;  constructor() &#123;    this.name = &quot;Apple&quot;;  &#125;  getType() &#123;    return this.name;  &#125;&#125;class Banana &#123;  constructor() &#123;    this.name = &quot;Banana&quot;;  &#125;  getType() &#123;    return this.name;  &#125;&#125;const FruitFactory = &#123;  getFruit: function (type) &#123;    switch (type) &#123;      case &quot;apple&quot;:        return new Apple();      case &quot;banana&quot;:        return new Banana();      default:        return null;    &#125;  &#125;,&#125;;const apple = FruitFactory.getFruit(&quot;apple&quot;);const banana = FruitFactory.getFruit(&quot;banana&quot;);console.log(apple.getType()); // Appleconsole.log(banana.getType()); // Banana\n\n4. 构造器模式\n构造器模式通过不同的函数以及方法向对象添加属性和方法。\n\nconst zhangsan = &#123;  name: &quot;张三&quot;,  age: 18,&#125;;const lisi = &#123;  name: &quot;李四&quot;,  age: 20,&#125;;const addJob = (obj) =&gt; &#123;  obj.job = &quot;老师&quot;;&#125;;const addAction = (obj) =&gt; &#123;  obj.action = &quot;睡觉&quot;;&#125;;addJob(zhangsan);console.log(zhangsan.job); // 老师addAction(lisi);console.log(lisi.action); // 睡觉\n\n5. 原型模式\n原型允许把一个对象作为蓝图创建另一个对象，新对象继承原对象的属性和方法。\n\n&#123;cmdconst person = &#123;  eat: () =&gt; console.log(&quot;吃饭&quot;),  sleep: () =&gt; console.log(&quot;睡觉&quot;),&#125;;const zhangsan = &#123;  name: &quot;张三&quot;,  age: 18,&#125;;// 将person设置为zhangsan的原型Object.setPrototypeOf(zhangsan, person);zhangsan.eat(); // 吃饭zhangsan.sleep(); // 睡觉\n\n\n\n\n","categories":["前端","javascript","设计模式"],"tags":["前端","笔记","javascript"]},{"title":"css世界-记录","url":"/741b471ab1bd/css%E4%B8%96%E7%95%8C-%E8%AE%B0%E5%BD%95/","content":"任意高度元素的展开收起动画使用 max-height 配合 transition 实现 ，当 max-height 比设定的 height 大的时候，元素的高度取 height 的值。\n.el &#123;  max-height: 0;  overflow: hidden;  transition: max-height 0.25s;&#125;.el.active &#123;  max-height: 1000px;&#125;\n\n需要注意，虽然 max-height 需要大于 height，但是需要 max-height 的值不能过大，这样会导致过渡动画可能不明显，比如，当前的元素高度是 100 像素，而 max-height 是 1000 像素，动画时间是 250ms，假设动画函数是线性的，则前 225ms 是看不到收起效果的，因为 max-height 从 1000 像素 到 100 像素 变化这段时间，元素不会有区域被隐藏，会给人动画延迟 225ms 的感觉。 所以需要给 max-height 设定一个足够安全（使动画按照预期发生）的值。\n幽灵空白节点在 HTML5 中，内联元素渲染后在页面的表现如同该元素盒子前有一个“空白节点”一样，这个“空白节点”是透明的、不占据宽度且无法通过代码获取，其表现如同文本节点。（非 HTML5 的内联元素不存在该现象）\n规范中实际上对这个“幽灵空白节点”是有提及的，“幽灵空白节点” 实际上也是一个盒子，不过是个假想盒，名叫“strut”，中文直译为“支柱”，是一个存在于每个“行框盒子”前面，同时具有该元素的字体和行高属性的0宽度的内联盒\n层叠上下文准则\n谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index 属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个\n后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素\n\n\n\n\n\n","categories":["前端","CSS"],"tags":["前端","CSS"]},{"title":"css计数器","url":"/1b3605bb078e/css%E8%AE%A1%E6%95%B0%E5%99%A8/","content":"CSS 可以通过其计数器功能实现不使用 js 在列表前添加序号等操作。\n1. 初始化计数器counter-reset: name number;\n\n\nname: 设定的计数器名称\nnumber：计数器初始值，默认为 0\n\n2. 操作值counter-increment: name number;\n\n\nname: 计数器名称\nnumber: 增加的值，默认为 1，可以设置为 0 和负数\n\n3.获取并显示值content: counter(name, style);\n\n\nname: 计数器名称\nstyle: 计数器样式，见 counter-style_计数器样式\n\n也可使用 counters\ncounters(name, string, style)\n\n\nname: 计数器名称\nstring: 用来定义多个计数器同时使用的连接符\nstyle: 计数器样式，\n\n例 1（使用 counter）&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;style&gt;      body &#123;        counter-reset: section;      &#125;      h2::before &#123;        counter-increment: section;        content: &quot;Section &quot; counter(section) &quot;: &quot;;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h2&gt;标题1&lt;/h2&gt;    &lt;h2&gt;标题2&lt;/h2&gt;    &lt;h2&gt;标题3&lt;/h2&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n\n效果如下\n\n\n\n  \n    \n    \n      body {\n        counter-reset: section;   \n      }\n      h2::before {\n        counter-increment: section;\n        content: \"Section \" counter(section) \": \";\n      }\n    \n  \n  \n    标题1\n    标题2\n    标题3\n  \n\n\n\n例 2（使用 counters）&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;style&gt;      ol &#123;        counter-reset: section;        list-style-type: none;      &#125;      li::before &#123;        counter-increment: section;        content: counters(section, &quot;.&quot;) &quot; &quot;;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;ol&gt;      &lt;li&gt;item&lt;/li&gt;      &lt;li&gt;        item        &lt;ol&gt;          &lt;li&gt;item&lt;/li&gt;          &lt;li&gt;item&lt;/li&gt;          &lt;li&gt;            item            &lt;ol&gt;              &lt;li&gt;item&lt;/li&gt;              &lt;li&gt;item&lt;/li&gt;              &lt;li&gt;item&lt;/li&gt;            &lt;/ol&gt;          &lt;/li&gt;          &lt;li&gt;item&lt;/li&gt;        &lt;/ol&gt;      &lt;/li&gt;      &lt;li&gt;item&lt;/li&gt;      &lt;li&gt;item&lt;/li&gt;    &lt;/ol&gt;    &lt;ol&gt;      &lt;li&gt;item&lt;/li&gt;      &lt;li&gt;item&lt;/li&gt;    &lt;/ol&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n效果如下\n\n\n\n  \n    \n    \n      ol {\n        counter-reset: s2;\n        list-style-type: none;\n      }\n      li::before {\n        counter-increment: s2;\n        content: counters(s2, \".\") \" \";\n      }\n    \n  \n  \n    \n      item\n      \n        item\n        \n          item\n          item\n          \n            item\n            \n              item\n              item\n              item\n            \n          \n          item\n        \n      \n      item\n      item\n    \n    \n      item\n      item\n    \n  \n\n\n\n\n\n\n\n","categories":["前端","CSS"],"tags":["前端","CSS"]},{"title":"github 工作流的使用和配置","url":"/8d5cedce3abf/github-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/","content":"\n官方文档\n\n1. 预备知识1.1 关键术语\nWorkflow：工作流，一个 GitHub Actions 项目的配置文件，定义了在仓库中触发事件时要执行的操作。格式为 YAML 文件, 存储在仓库的 .github/workflows 目录下, 每个文件对应一个工作流。\nJob：作业，一个工作流由多个作业组成，默认以并行的方式执行，可以配置为串行。\nStep：步骤，每个作业由多个步骤组成，每个步骤都是一个独立的操作，步骤是按顺序执行的。\nAction：操作，每个步骤都是一个操作，操作可以是 GitHub 提供的预定义操作，也可以是自定义的操作。\n\n1.2 文件结构你的项目/├── .github/│   └── workflows/│       ├── ci.yml     # 持续集成工作流│       ├── deploy.yml # 部署工作流|       └── ***.yml    # 其他工作流└── ***                # 其他项目文件\n\n2. 创建一个工作流2.1 示例以本项目工作流为例：\nname: Pageson:  push:    branches:      - master # default branchjobs:  build:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v4        with:          token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;          submodules: recursive      - name: Use Node.js 20        uses: actions/setup-node@v4        with:          node-version: &quot;20&quot;      - name: Cache NPM dependencies        uses: actions/cache@v4        with:          path: node_modules          key: $&#123;&#123; runner.OS &#125;&#125;-npm-cache          restore-keys: |            $&#123;&#123; runner.OS &#125;&#125;-npm-cache      - name: Install Dependencies        run: npm install      - name: Build        run: npm run build      - name: Upload Pages artifact        uses: actions/upload-pages-artifact@v3        with:          path: ./public  deploy:    needs: build    permissions:      pages: write      id-token: write    environment:      name: github-pages      url: $&#123;&#123; steps.deployment.outputs.page_url &#125;&#125;    runs-on: ubuntu-latest    steps:      - name: Deploy to GitHub Pages        id: deployment        uses: actions/deploy-pages@v4\n\n以上工作流用以在每次推送 master 分支时，自动构建并部署项目到 GitHub Pages。\n2.2 工作流程说明\n当master分支有新的提交时，触发工作流。\n工作流分为两个作业：build 和 deploy。\nbuild 作业负责构建项目，包括检查代码、安装依赖、构建项目等步骤。\ndeploy 作业负责部署项目，将构建好的项目部署到 GitHub Pages 。\ndeploy 作业配置了 needs: build，表示 deploy 作业依赖 build 作业的执行结果。此时这两个作业为串行执行，即只有当 build 作业执行完成后，deploy 作业才会执行。\n\n3. 触发机制\n工作流文件中定义on字段，用于指定触发工作流的事件。它可以配置单个或多个事件，如果指定多个事件，仅需发生其中一个事件就可触发工作流。 如果触发工作流的多个事件同时发生，将触发多个工作流运行。单个事件：on: push多个事件：on: [push, fork]\n\n完整的触发机制内容参考官方文档\n\n\n\n\n","categories":["学习","github","工作流"],"tags":["学习","github","工作流"]},{"title":"JavaScript忍者秘籍（四）","url":"/a4b5ed670eba/JavaScript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"原型理解原型\n每个对象都含有原型的引用，当查找属性时，若对象本身不具有该属性，则会查找原型上是否有该属性。\n每个对象都可以有一个原型，每个对象的原型也可以拥有一个原型，以此类推，形成一个原型链。查找特定属性将会被委托在整个原型链上，只有当没有更多的原型可以进行查找时，才会停止查找。\n\n对象构造器与原型首先我们创建一个最简单的对象：\nconst person = &#123;&#125;;\n\n之后我们可以通过赋值语句给它添加属性：\nconst person = &#123;&#125;;person.name = &quot;张三&quot;;person.age = 20;\n\n如果我们要创建一个拥有相同属性的多个对象，我们可以使用构造函数。但是构造函数是用来初始化对象为已知的初始状态。毕竟，如果我们要创建多个相同类型的对象的实例，为每个实例单独进行属性分配，不仅繁琐，而且非常容易出错。我们希望能够在一个地方将这些对象的属性和方法整合为一个类。\nJavaScript 通过构造函数初始化新对象，但是没有真正的类定义。通过操作符new，应用于构造函数之前，触发创建一个新对象分配。\n还有一点是，每个函数都有一个原型对象，该原型对象被自动设置为通过该函数创建的每个新对象的原型。\nfunction fun1() &#123;&#125;fun1.prototype.action = function () &#123;  return true;&#125;;const obj1 = fun1();console.log(obj1); // undefinedconst obj2 = new fun1();console.log(obj2); // fun1&#123;&#125;\n\n通过以上代码可以看出，通过new关键字创建出的对象包含了fun1函数原型上的方法。\n实例属性当把函数作为构造函数，通过操作符new进行调用时，它的上下文被定义为新的对象实例。通过原型暴露属性，通过构造函数的参数进行初始化。\nfunction Ninja() &#123;  this.swung = true;  this.swingSword = function () &#123;    return !this.swung;  &#125;;&#125;Ninja.prototype.swingSword = function () &#123;  return this.swung;&#125;;const ninja = new Ninja();console.log(ninja.swingSword()); // false\n\nJavaScript 动态特性的副作用由于 JavaScript 的动态特性，我们可以在运行时给对象添加属性。\nfunction Ninja() &#123;  this.swung = true;&#125;const ninja1 = new Ninja(); // 创建一个Ninja实例/** 在实例创建后向原型上添加一个方法 */Ninja.prototype.swingSword = function () &#123;  return this.swung;&#125;;/** 验证实例上有没有实例化后的新增方法 */console.log(ninja1.swingSword()); // true/** 重写Ninja的原型 */Ninja.prototype = &#123;  pierce: function () &#123;    return true;  &#125;,&#125;;/** 由于实例保留原有的原型对象，所以在实例化之后对原型的重写不会被应用在已经创建的实例上 */console.log(ninja1.pierce()); // Uncaught TypeError: ninja1.pierce is not a functionconst ninja2 = new Ninja();/** 最新的实例会应用最新的原型对象 */console.log(ninja2.pierce()); // true\n\n所以我们得到一个结论：对象与函数原型之间的引用关系是在对象创建时建立的，新创建的对象将引用新的原型，而旧的对象会保留着原有的原型引用。\n通过构造函数实现函数对象function Ninja() &#123;&#125;const ninja = new Ninja();console.log(ninja instanceof Ninja); // true\n\n通过示例我们可以使用instanceof操作符来判断对象是否为某个构造函数的实例。接下来我们可以使用对象的constructor属性来创建新的对象。\nfunction Ninja() &#123;&#125;const ninja = new Ninja();const ninja2 = new ninja.constructor();/** * 由于ninja的constructor属性是Ninja原型的引用 * 所以通过constructor创建的ninja2也是Ninja的实例 */console.log(ninja2 instanceof Ninja); // true/** 但是两个对象是独立的 */console.log(ninja2 === ninja); // false\n\n使用原型实现继承function Person() &#123;&#125;Person.prototype.dance = function () &#123;&#125;;function Ninja() &#123;&#125;Ninja.prototype = new Person(); // 通过将原型设为实例化后的Person对象，实现继承const ninja = new Ninja();console.log(ninja instanceof Ninja); // trueconsole.log(ninja instanceof Person); // trueconsole.log(ninja instanceof Object); // trueconsole.log(typeof ninja.dance === &quot;function&quot;); // true\n\n原型关系图:\ngraph TD;\nA[ninja实例] --&gt;|__proto__| B[new Person&lt;br&gt;Ninja.prototype]\n    B --&gt;|__proto__| C[Person.prototype&lt;br&gt;包含dance方法]\n    C --&gt;|__proto__| D[Object.prototype]\n    D --&gt;|__proto__| E[null]\n\n    F[instanceof Ninja: true] --&gt; A\n    G[instanceof Person: true] --&gt; A\n    H[instanceof Object: true] --&gt; A\n    I[ninja.dance: function] --&gt; A\n\n    B -.-&gt;|constructor| J[Person构造函数]\n    C -.-&gt;|constructor| J\n\n    style A fill:#e1f5fe\n    style B fill:#fff3e0\n    style C fill:#f3e5f5\n    style D fill:#e8f5e8\n    style J fill:#ffebee\n\n解决继承中构造器constructor被覆盖的问题为了使Ninja继承Person，我们使用了Ninja.prototype = new Person();。但是这会覆盖掉原型上的constructor属性，使ninja.constructor指向Person，而不是Ninja。这导致了我们的ninja丢失了与Ninja构造函数之间的联系。此时我们可以通过Object.defineProperty方法来修正这个问题。\n\nJavaScript中，对象是通过属性描述（property descriptor）进行描述的，我们可以配置以下关键字。\n\nconfigurable —— 如果设为true，则可以修改或删除属性。如果设为false，则不允许修改。\nenumerable —— 如果设为true，则可在for-in循环对象属性时出现。\nvalue —— 指定属性的值，默认为undefined。\nwritable —— 如果设为true，则可通过赋值语句修改属性值。\nget —— 定义getter函数，当访问属性时发生调用，不能与value与writable同时使用。\nset —— 定义setter函数，当对属性赋值时发生调用，也不能与value与writable同时使用。\n\n\nfunction Person() &#123;&#125;Person.prototype.dance = function () &#123;&#125;;function Ninja() &#123;&#125;Ninja.prototype = new Person();/** 手动设置constructor属性，将其重置为Ninja */Object.defineProperty(Ninja.prototype, &quot;constructor&quot;, &#123;  enumerable: false,  value: Ninja,  writable: true,&#125;)const ninja = new Ninja();console.log(ninja instanceof Ninja); // trueconsole.log(ninja instanceof Person); // true\n\n使用ES6定义类class Ninja &#123;&#125;const ninja = new Ninja();\n继承class Person &#123;  dance()&#123;    return true;  &#125;&#125;class Ninja extends Person &#123;  constructor() &#123;    super(); // 调用父类的构造函数  &#125;&#125;const ninja = new Ninja();console.log(ninja instanceof Ninja); // trueconsole.log(ninja instanceof Person); // trueconsole.log(ninja.dance()); // true\n使用es6的语法，我们不需要手动设置原型和构造器。\n\n\n\n\n","categories":["前端","javascript"],"tags":["前端","笔记","javascript","JavaScript忍者秘籍"]},{"title":"hexo配置aPlayer播放器","url":"/f95cfd58c53a/hexo%E9%85%8D%E7%BD%AEaplayer%E6%92%AD%E6%94%BE%E5%99%A8/","content":"首先安装 hexo-tag-aplayer 插件 npm install hexo-tag-aplayer --save\n然后在主题配置文件 _config.**.yml 文件中添加配置\naplayer:  asset_inject: true  # 自动插入 Aplayer.js 与 Meting.js 资源脚本, 默认开启  meting: true # 启用 metingjs\n之后根据官方文档进行配置即可 hexo-tag-aplayer\n这里主要介绍配置aPlayer全局播放的配置方式\n首先设置 asset_inject 为 false，之后在主题的配置文件中使用 inject 注入aPlayer的dom结构，由于需要全局播放所以需要开启 pjax 功能。注意 pjax 和 aplayer 配置项在同一个配置文件中最好。\naplayer:  asset_inject: false  meting: truepjax:  enable: trueinject:  bottom:    # 注入音乐播放器    - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;&quot; data-server=&quot;&quot; data-type=&quot;&quot; data-fixed=&quot;&quot; data-autoplay=&quot;&quot;&gt; &lt;/div&gt;\naplayer使用的参数如下：\n\n\n\n选项\n默认值\n描述\n\n\n\ndata-id\n必填\n音乐id、播放列表id、相册id、搜索关键字\n\n\nserver\n必填\n音乐数据源：netease（网易云）、tencent（QQ音乐）、kugou、xiaomi、baidu\n\n\ntype\n必填\nsong（音乐）、playlist（播放列表，歌单）、album、search（关键词搜索）\n\n\nfixed\nfalse\n是否开启固定模式\n\n\nmini\nfalse\n是否开启迷你模式\n\n\nloop\nall\n列表循环模式：all,one,none\n\n\norder\nlist\n列表播放模式：list,random\n\n\nautoplay\ntrue\n是否自动播放,根据浏览器规则可能不可用\n\n\nvolume\n0.7\n初始音量，范围为0到1\n\n\npreload\nauto\n预加载模式：none,metadata,auto\n\n\ntheme\n#ad7a86\n主题颜色，支持16进制颜色代码\n\n\nlistmaxheight\n340px\n播放列表最大高度，单位为px\n\n\nmutex\ntrue\n互斥模式，开启后同一时间只能播放一个播放器实例\n\n\nlistfolded\nfalse\n列表折叠状态，默认不折叠\n\n\naPlayer 官方文档：APlayer\n\n\n\n\n","categories":["hexo"],"tags":["hexo","aPlayer"]},{"title":"乐理1","url":"/440bee6d4f7b/%E4%B9%90%E7%90%861/","content":"钢琴键盘排布以及音名钢琴键盘去除左侧三个键及右侧一个键，以5个黑键、7个白键组成，其中黑键为2+3排布。音名：\n升降号和还原号黑键的音名\n#表示升号，♭表示降号。如C#表示升C，D♭表示降D。\n由于EF之间没有黑键，则E可以叫做F♭，F叫做E#。这里叫做等音。\n还原符号♮表示还原到等音。如C#♮表示C，D♭♮表示D。\n重升号（写作“𝄪”或“×”），重降号♭♭。等于两次联系升半音或降半音（一个全音）。\n音符时值的关系常见的音符时值\n全音符： X—\n二分音符：X-\n四分音符：X\n八分音符：X\n十六分音符：X 下两个横线\n三十二分音符：X 下三个横线\n\n全音符的时值是二分音符的两倍，是四分音符的四倍，是八分音符的八倍，依次类推。\n拍号以 4&#x2F;4 分数为例，表示每个四分音符为一个拍，每小节有4个拍。带入音符时值则为\n小节每个小节以 | 分隔，每个拍之间以空格分隔。根据每一小节中的音符时值，计算出这一小节的时值从而得出该小节的对错。\n\n\n\n\n","categories":["学习","乐理"],"tags":["学习","乐理"]},{"title":"乐理2","url":"/f74a2ec788f7/%E4%B9%90%E7%90%862/","content":"BMP 歌曲速度每分钟节拍数的单位，其与节拍的关系为：60&#x2F;BMP &#x3D; 每一拍的时间（秒）。\n例：\n表示：一个4&#x2F;4拍，速度为60的音乐，每一拍的速度为1秒，且每一拍为四分音符。\n附点音符附点X分音符 &#x3D; X分音符 + X分音符的一半，例如附点4分音符 &#x3D; 4分音符 + 4分音符的一半 等于 4分音符 + 8分音符\n附点音符的写法为在音符后加点，例如 X· 表示4分音符的附点音符。\n三连音三连音表示将一个整体分割为均等的三份。四分音符的三连音指把二分音符作为整体平均分为3份。\n实际为使指定的单个音符占用的两个长度作为整体再均分为三份。即使用演奏两个音符的时间来演奏三个音符。\n唱名与简谱数字\n\n\n名称\n\n\n\n\n\n\n\n\n\n\n唱名\ndo\nre\nmi\nfa\nso\nla\nsi\n\n\n简谱数字\n1\n2\n3\n4\n5\n6\n7\n\n\n\n自然大调(白)当简谱中标注1=C时，自然大调的音名顺序为 C D E F G A B C。\n不管1等于几，调式内部排列的规律都是一致的。\n自然大调的排列规律为：全 全 半 全 全 全 半\n由此可得G大调为：G A B C D E F# G。由于每个音名必须在调式中出现，故使用F#而不是G♭。\n自然大调(黑)当音名使用黑键时，通常使用降音名为开头。\n自然小调小调的音阶唱名以la为首音，而不是do。\n由A小调开始，小调的规律为：全 半 全 全 半 全 全\n另，我们可以由小调对应的关系大调来找到对应小调的音名顺序。\n\n当我们需要知道A小调的音名顺序时，我们可以先将A往后移动一个半音阶（一个全音+一个半音）得到C，这里就是A小调对应的关系大调的开始位置。由规律我们得出C大调的音阶为：C D E F G A B C。之后移动最后6,7的音名到开头，去除最后一个音名C【因为最后一个C实际的简谱值为1】，得到A小调的音名顺序：A B C D E F G A。\n\n\n\n\n\n","categories":["学习","乐理"],"tags":["学习","乐理"]},{"title":"伊人梦","url":"/05f9f46ae0a2/%E4%BC%8A%E4%BA%BA%E6%A2%A6/","content":"\n  a0c3088a6e0b287c227b0cac8407eebb43c0b356e41f14b2fa4cdc3ea2ce0abd002c269426e472775f1e6b973957dbd2a61a10b63d8687d5fe7d9c8e4adb6a5a2e9ead1d8a066c686f66ba1899f8244a2b40e0b880fef2277cd5ec18363e66491d5a307526fdfc44e5c9af4708467db889501dce7776c5df2eac2014d2db423e33827f9b32c6204085003f12a39bf801b1a3777a2af0bd7f1cedb53751a8b43e5438ef759a29cf3712752718b7279e245bc6f4494e9243142a8abb81c7b44b694f83967927d1fd7840a3d357217e8fdb68b7f92ab133865180b994d45876f7d8795755c4abe4b7c611bae295c782530e08bde7ce5cb652fcf00e074023ecafd89eed1916d26fcaec46941ba0c86998c92e3cdfd78b21afa6ca2706e8b91773cede36e0164eb86f9975c35a46038b42dd0c7e771ae6199681148c9662a24845536e8345a967a2a53619a87ef1cdedf0501980a639446b1cf3a8571c6a8e23cc2c00bc153936375e9ac6ec8dedc8415e04dfac4184458c6527d7209c34ca1b478648721108e431887e305ec1e79d295fbee5b0afefc35fa347ec8ac481f234f956d424e0e777f146a399e1a24b09120e33c0dc5afb041fe322f294e10ff84bdf1c2a05260a7e59f29f78fcba4b71aae029d57a3e8bed6a47e8713b1415d724043290e0b4be9c2d03b30d3f82d977cc50a15e53cf1fbbd4efe047406097e44865e2ea9e4d4c27b839887209334231b7f6b0c84fdce6523cefdbe738f289efb08a710cd49b81df8e5ee848aa8791d8e6192df31f48d86dbcbb5974379d5513b2ec338d2a21dd3eed28c46c58241a8855f5cad814c9f1a558b9ce3524763b2ba43af2cadf4e8afe06cffa99c1f5f1f1f9a1cda94c630563148e25e50e825a83e7fb7362f701823af7fdf5a9b17493d875149dcdeeee234ba12ce5460905e54de8d87f372520687120fbc4d396619195c8f28e2285cfd8845bb2e13c35bb364f4fbbc9c1ef54a8b1daea98bfe96df44ced3c300dcc2a4b698eea60929772d4484863567fd02e5ffffe70d7963973ff627dd1985d12441d2b80bbd86ef76443d8a475ceeaacd1e1996444ec860c8e3036a4e9f8a01d1bec8392640566d526c8b3125b1e067e66b6b0bbc26ae65275ac47d5e314c5a173c14cd3b01c42457f72fc69d27ac83895d8602f07390947db4231379b847296e6c28200dc7a1b6f54281ba2af04ec986be444e63fec819a8b0888e05c0c91ae85a21d75d7ff94bb37fa74aafc02f745af0fe206d740e904ce3c6775834f5da3954592052caf41be476fd7f2772b2941409f009d9133fea8b15cb606dcf344bfbb9f9d3437db72e869e64f5d22cd2ce21f9877ef012e050695d7c977e954134ebf4aad9f5385a28e20a2e5b614734598eb313a7f52c3d3a776d9c2e88745\n  \n    \n      \n      \n        快输密码吧\n      \n    \n  \n\n","categories":["日常"],"tags":["日常"]},{"title":"乐理3","url":"/4aa730a4049b/%E4%B9%90%E7%90%863/","content":"音程音程是指在钢琴键上两个音之间的距离，例如D-&gt;B为6度，注意计算时要包含开头和结尾的音\n当需要计算升音或降音时，需要将其还原，如C#转为C, D♭转为D,再行计算。\n音程的属性纯、大音程\n      {\"content\":\"&#x97f3;&#x7a0b;\",\"children\":[{\"content\":\"&#x7eaf;\",\"children\":[{\"content\":\"1&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;C\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"8,9\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"7,9\"}},{\"content\":\"4&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;F\",\"children\":[{\"content\":\"6&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"11,12\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"10,12\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"9,12\"}},{\"content\":\"5&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;G\",\"children\":[{\"content\":\"8&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"14,15\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"13,15\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"12,15\"}},{\"content\":\"8&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;&#x9ad8;&#x97f3;C\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"16,17\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"15,17\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"6,17\"}},{\"content\":\"&#x5927;\",\"children\":[{\"content\":\"2&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;D\",\"children\":[{\"content\":\"3&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"20,21\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"19,21\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"18,21\"}},{\"content\":\"3&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;E\",\"children\":[{\"content\":\"5&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"23,24\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"22,24\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"21,24\"}},{\"content\":\"6&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;A\",\"children\":[{\"content\":\"10&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"26,27\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"25,27\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"24,27\"}},{\"content\":\"7&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;B\",\"children\":[{\"content\":\"12&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"29,30\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"28,30\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"27,30\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"17,30\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"5,30\"}}\n      {\"zoom\":false,\"pan\":false}\n    \n\n\n除了4度5度为纯音程，其他都是大音程\n\n小、减、倍减、增、倍增\n      {\"content\":\"&#x97f3;&#x7a0b;\",\"children\":[{\"content\":\"&#x5c0f;\",\"children\":[{\"content\":\"&#x6bd4;&#x5927;&#x97f3;&#x7a0b;&#x5c11;1&#x4e2a;&#x952e;\",\"children\":[{\"content\":\"2&#x5ea6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"8,9\"}},{\"content\":\"3&#x5ea6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"9,10\"}},{\"content\":\"6&#x5ea6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"10,11\"}},{\"content\":\"7&#x5ea6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"11,12\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"7,12\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"6,12\"}},{\"content\":\"&#x51cf;\",\"children\":[{\"content\":\"&#x6bd4;&#x7eaf;&#x97f3;&#x7a0b;&#x5c11;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"13,14\"}},{\"content\":\"&#x6bd4;&#x5c0f;&#x97f3;&#x7a0b;&#x5c11;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"14,15\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"12,15\"}},{\"content\":\"&#x500d;&#x51cf;\",\"children\":[{\"content\":\"&#x6bd4;&#x51cf;&#x97f3;&#x7a0b;&#x5c11;&#x4e00;&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"16,17\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"15,17\"}},{\"content\":\"&#x589e;\",\"children\":[{\"content\":\"&#x6bd4;&#x7eaf;&#x97f3;&#x7a0b;&#x591a;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"18,19\"}},{\"content\":\"&#x6bd4;&#x5927;&#x97f3;&#x7a0b;&#x591a;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"19,20\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"17,20\"}},{\"content\":\"&#x500d;&#x589e;\",\"children\":[{\"content\":\"&#x6bd4;&#x589e;&#x97f3;&#x7a0b;&#x591a;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"21,22\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"20,22\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"5,22\"}}\n      {\"zoom\":false,\"pan\":false}\n    \n\n\n如A到C为三度音程，但是A到C只有4个键，由于小音程的定义为比大音程小1度，所以A到C为小音程（即小3度）。\n\n总结\n      {\"content\":\"&#x97f3;&#x7a0b;\",\"children\":[{\"content\":\"&#x7eaf;\",\"children\":[{\"content\":\"1&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;C\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"8,9\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"7,9\"}},{\"content\":\"4&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;F\",\"children\":[{\"content\":\"6&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"11,12\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"10,12\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"9,12\"}},{\"content\":\"5&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;G\",\"children\":[{\"content\":\"8&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"14,15\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"13,15\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"12,15\"}},{\"content\":\"8&#x5ea6;\",\"children\":[{\"content\":\"C&#x5230;&#x9ad8;&#x97f3;C\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"16,17\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"15,17\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"6,17\"}},{\"content\":\"&#x5927;\",\"children\":[{\"content\":\"2&#x5ea6;\",\"children\":[{\"content\":\"3&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"19,20\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"18,20\"}},{\"content\":\"3&#x5ea6;\",\"children\":[{\"content\":\"5&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"21,22\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"20,22\"}},{\"content\":\"6&#x5ea6;\",\"children\":[{\"content\":\"10&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"23,24\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"22,24\"}},{\"content\":\"7&#x5ea6;\",\"children\":[{\"content\":\"12&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"25,26\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"24,26\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"17,26\"}},{\"content\":\"&#x5c0f;\",\"children\":[{\"content\":\"&#x6bd4;&#x5927;&#x97f3;&#x7a0b;&#x5c11;1&#x4e2a;&#x952e;\",\"children\":[{\"content\":\"2&#x5ea6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"28,29\"}},{\"content\":\"3&#x5ea6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"29,30\"}},{\"content\":\"6&#x5ea6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"30,31\"}},{\"content\":\"7&#x5ea6;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"31,32\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"27,32\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"26,32\"}},{\"content\":\"&#x51cf;\",\"children\":[{\"content\":\"&#x6bd4;&#x7eaf;&#x97f3;&#x7a0b;&#x5c11;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"33,34\"}},{\"content\":\"&#x6bd4;&#x5c0f;&#x97f3;&#x7a0b;&#x5c11;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"34,35\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"32,35\"}},{\"content\":\"&#x500d;&#x51cf;\",\"children\":[{\"content\":\"&#x6bd4;&#x51cf;&#x97f3;&#x7a0b;&#x5c11;&#x4e00;&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"36,37\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"35,37\"}},{\"content\":\"&#x589e;\",\"children\":[{\"content\":\"&#x6bd4;&#x7eaf;&#x97f3;&#x7a0b;&#x591a;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"38,39\"}},{\"content\":\"&#x6bd4;&#x5927;&#x97f3;&#x7a0b;&#x591a;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"39,40\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"37,40\"}},{\"content\":\"&#x500d;&#x589e;\",\"children\":[{\"content\":\"&#x6bd4;&#x589e;&#x97f3;&#x7a0b;&#x591a;1&#x4e2a;&#x952e;\",\"children\":[],\"payload\":{\"tag\":\"li\",\"lines\":\"41,42\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"40,42\"}}],\"payload\":{\"tag\":\"li\",\"lines\":\"5,42\"}}\n      {\"zoom\":false,\"pan\":false}\n    \n\n\n练习\n升C到降A\n\n\n先将升C和降A还原为C和A，计算白键个数后得6度\n再计算升C到降A直接总共有8个键\n由于大6度有10个键，所以升C到降A为减6度\n大六度（10）\n小六度（9）\n减六度（8）\n\n\n\n\nE到降F\n\n\n先将E和降F还原为E和F，计算白键个数后得2度\n再计算E到降F直接总共有1个键\n由于大2度有3个键，所以E到降F为减2度\n大二度（3）\n小二度（2）\n减二度（1）\n\n\n\n\n\n\n\n","categories":["学习","乐理"],"tags":["学习","乐理"]},{"title":"微信小程序构建npm","url":"/cbcd0deeb7dd/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9E%84%E5%BB%BAnpm/","content":"在微信小程序中初始化 npm从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。\n初始化 npm\n在小程序项目根目录下执行 npm init 命令，生成 package.json 文件。\n\n在 package.json 中添加依赖包：\nnpm install --save &lt;package-name&gt;@&lt;version&gt;\n\n\n如果仅需要初始化而暂时不安装依赖，可以在 package.json 目录下创建一个空的 node_modules 目录。\n\n\n安装依赖后设置project.config.json：\n&#123;  &quot;setting&quot;: &#123;    &quot;packNpmManually&quot;: true,    &quot;packNpmRelationList&quot;: [      &#123;        &quot;packageJsonPath&quot;: &quot;./package.json&quot;,        &quot;miniprogramNpmDistDir&quot;: &quot;./&quot;      &#125;    ]  &#125;&#125;\n\n打开”工具”-&gt;”构建 npm”，点击“确定”开始构建。\n\n\n\n\n\n\n","categories":["前端","微信小程序"],"tags":["npm"]},{"title":"文件上传","url":"/e3d1edfed0ad/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","content":"文件分片上传分片上传主要解决文件过大导致上传时间长的问题，将大文件分割成多个小块进行上传。由于浏览器请求限制，现在浏览器对同一域名的最大请求并发数通常为 6 个（不同浏览器可能限制不同）。\n前端通过Blob.prototype.slice()方法对文件进行分片，然后通过FormData对象将每个分片封装成表单数据。\nasync function onUpload(e) &#123;  if (!e.target.files[0]) return alert(&quot;No file selected&quot;);  const file = e.target.files[0];  const chunkSize = 1024 * 1024 * 5; // 分片大小，这里为5MB  const chunkTotal = Math.ceil(file.size / chunkSize); // 分片数量  /**   * 1. 获取文件hash作为标识   * 2. 创建切片   * 3. 将切片转换为formData   */  const taskPool = formDatas.map(    (formData) =&gt; () =&gt;      fetch(&quot;http://localhost:3000/upload&quot;, &#123;        method: &quot;POST&quot;,        body: formData,      &#125;)  );  /**   * 并发发送请求，并发数为6个   */  await concurRequest(taskPool, 6);&#125;\n\n代码地址\n服务端\n此处服务端使用express框架，接收前端发送的分片文件。\n需要使用multiparty中间件来解析表单数据，并通过文件名来判断是哪个分片。\n本文所用分片文件名格式为 文件hash-分片序号\n\n(req, res) =&gt; &#123;  const form = new multiparty.Form();  // 真实文件保存地址  const uploadDir = &quot;./files&quot;;  // 分片文件缓存地址  const chunkDir = &quot;./cache&quot;;  form.parse(req, async (err, fields, files) =&gt; &#123;    if (err) return res.status(500).send(&quot;Error&quot;);    /**     * 从formData中获取文件信息并存入对应缓存目录     * 当所有分片上传完成，通过文件流合并分片还原原始文件到最终文件目录     * 删除缓存的分片文件     * /  &#125;)&#125;;\n\n代码地址\n可能出现的问题\n在 windows 系统下，系统默认缓存在 C 盘。当服务端程序在非 C 盘分区且进行合并操作时可能出现文件合并失败的问题。本文放弃了文件移动操作，将文件复制到目标目录下，再行清除缓存。\n\n由于使用并发上传，所以可能出现多个分片同时到达服务器的情况，此时直接合并文件会导致出现两个最终文件的情况（最终文件文件名有 hash 或时间戳等随机串），本文采用了文件合并锁的方式来解决这个问题。\n// 设置合并锁const fileMergeLocks = new Set();/** * 处理分片代码 */if (chunkFiles.length === parseInt(chunkTotal)) &#123;  if (fileMergeLocks.has(fileHash)) &#123;    return res.status(200).send(&quot;文件正在合并中,跳过合并操作&quot;);  &#125; else &#123;    // 当前文件没有在合并队列时，将当前文件加入锁列表并开始合并    fileMergeLocks.add(fileHash);    try &#123;      /**       * 文件合并代码       */    &#125; finally &#123;      // 无论文件是否合并成功，都从锁列表中移除      fileMergeLocks.delete(fileHash);    &#125;  &#125;  /**   * 其他操作   */&#125;\n\n\n\n\n\n","categories":["前端"],"tags":["前端","文件上传"]},{"title":"记一次关于组件以函数为参数产生的问题","url":"/876cd96655a5/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8E%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%87%BD%E6%95%B0%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/","content":"今天在完成一个带有文件上传的表单时，遇到了一个无限循环渲染导致栈溢出的问题。\n起因是有一个根据配置项渲染的表单页\n&lt;template&gt;  &lt;ElForm&gt;    &lt;template v-for=&quot;(item,index) in options&quot; :key=&quot;index&quot;&gt;      &lt;ElFormItem&gt;        &lt;!-- 省略其他项渲染 --&gt;        &lt;template v-if=&quot;item.type === &#x27;upload&#x27; &amp;&amp; item.uploadType === &#x27;image&#x27;&quot;&gt;          &lt;ElUpload :on-remove=&quot;onFileRemove(item.value)&quot;&gt;            &lt;!-- 内部插槽 --&gt;          &lt;/ElUpload&gt;        &lt;/template&gt;      &lt;/ElFormItem&gt;    &lt;/template&gt;  &lt;/ElForm&gt;&lt;/template&gt;&lt;script setup&gt;  /** 页面数据 */  const baseInfo = ref(&#123;&#125;);  const options = [    &#123;      label: &quot;编号&quot;,      value: &quot;num&quot;,      type: &quot;input&quot;,    &#125;,    &#123;      label: &quot;类型&quot;,      value: &quot;type&quot;,      type: &quot;select&quot;,    &#125;,    &#123;      label: &quot;图片&quot;,      value: &quot;img&quot;,      type: &quot;upload&quot;,      uploadType: &quot;image&quot;,    &#125;,  ];  const onFileRemove = (type) =&gt; &#123;    baseInfo.value[type] = [];  &#125;;&lt;/script&gt;\n\n此处由于开发时的热重载机制，完成的时候并没有出现问题。后续打开的时候就出现循环渲染的问题，导致同页面其他模块无法渲染，且出现提交表单时文件被清除的问题。\n经过排查，发现是因为 onFileRemove 函数每次渲染都会重新生成，导致 ElUpload 组件的 on-remove 事件每次都会触发，从而产生循环渲染。\n&lt;ElUpload :on-remove=&quot;()=&gt;onFileRemove(item.value)&quot;&gt; &lt;/ElUpload&gt;\n改成这样就恢复正常了，但是由于一时的粗心排查该问题花了不少时间，遂记录下来，引以为戒。\n\n\n\n\n","categories":["记录"],"tags":["vue","element-plus","bug"]},{"title":"阅读 2026-02-24","url":"/8d3ccb048fd2/%E9%98%85%E8%AF%BB-2026-02-24/","content":"\n生命本无意义，是我们使它有意义，是“我“，使生命获得意义。 —— 《病隙碎笔》 史铁生\n神，乃有限此岸向着无限彼岸的眺望，乃相对价值向着绝对之善的投奔，乃孤苦的个人对广博之爱的渴盼与祈祷。 —— 《病隙碎笔》 史铁生\n爱，即孤立的音符或段落向着那美丽与和谐的皈依，再从那美丽与和谐中互相发现：原来一切都是相依相随。 —— 《病隙碎笔》 史铁生\n文学，可以是从无中的创造，就是说它可以虚拟，可以幻想，可以荒诞不经，无中生有，只要能表达你的情思和心愿，其实怎么都行，唯真诚就好。 —— 《病隙碎笔》 史铁生\n总是以自己的好看要求别人的好看，这习惯在别人看来真是不好看。 —— 《病隙碎笔》 史铁生\n人以一个孤独的音符处于一部浩瀚的音乐中，难免恐惧。这恐惧是因为，他知道自己的心愿，却不知道别人的心愿；他知道自己复杂的处境与别人相关，却不知道别人对这复杂的相关取何种态度；他知道自己期待着别人，却没有把握别人是否对他也有着同样的期待；总之，他既听见了那音乐的呼唤，又看见了社会美德的阴沉脸色。这恐惧迫使他先把自己藏起来，藏到甚至连自己也看不到的地方去。但其实这不可能，他既藏了就必然知道藏了什么和藏在了哪儿，，只是佯装不知。这，其实不过是一种防御。他藏好了，看看没什么危险了，再去偷看别人。看别人的什么呢？看别人是否也像自己一样藏了和藏了什么。其实，他是要通过偷看别人来偷看自己，通过看见别人之藏而承认自己之藏，通过解开别人的藏而一步步解救着自己的藏————这从恋人们由相互试探到相互敞开的过程，可得证明。是啊，人，都在一个孤独的位置上期待着别人，都在一亿个孤独的音符而追随那浩瀚的音乐，以期生命不再孤独，不再恐惧，由爱的途径重归灵魂的伊甸园。—— 《病隙碎笔》 史铁生\n尴尬是一种可贵的能力。因为，反躬自问是一切爱愿与思想的初萌。要是你忽然发现你处在了尴尬的地位，这不值得惊慌，也最好不要逃避，莫如由着他日日夜夜惊扰你的良知，质问你的信仰，激活你的思想；进退维谷之日正可能是别有洞天之时，这差不多能算规律。—— 《病隙碎笔》 史铁生\n\n\n\n\n\n","categories":["阅读"],"tags":["阅读"]},{"title":"阅读 2026-02-23","url":"/a33e81e8aab7/%E9%98%85%E8%AF%BB-2026-02-23/","content":"\n不管怎么说，给爱下定义是要惹上帝发笑的。不如先绕开它，换个角度，这样问：什么时候，你第一次感到了爱？或者是在什么样的时候，你感到了需要爱？ —— 《病隙碎笔》 史铁生\n自卑，历来送给人间两样东西：爱的期盼，与怨愤的积累。 —— 《病隙碎笔》 史铁生\n**爱，原就是自卑弃暗投明的时刻。**自卑，或者在自卑的洞穴里步步深陷，或者转身，在爱的路途上迎候解放。—— 《病隙碎笔》 史铁生\n爱之永恒的能量，在于人之间永恒的隔膜。爱之永远的激越，由于每一个“我”都是孤独。人不仅是被抛到这个世界上来的，而且是一个个分开着被抛来的。—— 《病隙碎笔》 史铁生\n爱是软弱的时刻，是求助于他者的心情，不是求助于他者的施予，是求助于他者的参加。爱，即分割之下的残缺向他者呼吁完整，或者竟是，向地狱要求天堂。爱之所以艰难，常常落入窘境。—— 《病隙碎笔》 史铁生\n写作不过是为心魂寻一条活路，要在汪洋中找到一条船。—— 《病隙碎笔》 史铁生\n生命的意义不在向外的寻取，而在向内的建立。—— 《病隙碎笔》 史铁生\n\n\n\n\n\n","categories":["阅读"],"tags":["阅读"]},{"title":"阅读 2026-02-25","url":"/6e11a208e2a8/%E9%98%85%E8%AF%BB-2026-02-25/","content":"\n所有的大人，都曾是孩子。（但是他们中很少有人能记得这件事）《小王子》\n\n\n如果有个人爱上了一朵花，虽然在成千上百万颗星星之中，那朵花只存在于一颗星星上面，但只要望着这些星星，他就会感到幸福。他会对自己说：“我的花儿就在那里，在其中一颗星星上面……” 但是，如果绵羊吃掉了这朵花，这对他来说，就像忽然之间，所有的星星都熄灭了！这难道不重要吗？\n要评判一个人，不应该听她说了什么，而应该看她做了什么。她给了我香气，把我整个人都照亮了。我真不该逃跑！我本该猜到她那拙劣的小花招儿背后的一片柔情。花儿总是如此表里不一！可惜我当时太年轻了，还不懂如何去爱她。\n如果我命令一个将军变成一只海鸟，而那个将军不服从，这就不是他的错。这是我的错。\n这些星星闪闪发亮，是不是为了有一天，每个人都能找到属于他自己的那一颗？瞧我的那颗星星。它恰好就在我们头顶上……可它是那么遥远！\n现在对我来说，你还只是一个小男孩儿，跟成千上万别的男孩儿没什么两样。我不需要你，你也不需要我。我对你来说，也只不过是只狐狸，跟成千上万别的狐狸也没什么两样。但是，你要是驯养了我，我们就彼此需要了。你对我来说，就会是世界上独一无二的。我对你来说，也是世界上独一无二的……\n你们很美，但你们是空洞的，”小王子接着说，“没有人能为你们去死。当然，我的玫瑰花在一个路人眼里或许也和你们一样。但是对我来说，仅仅是她一朵，就比你们所有都来得重要，因为我用水浇灌过的是她，我用罩子罩过的是她，我用屏风遮蔽的是她，我除过毛毛虫（除了留下两三条来变成蝴蝶）的也是她。因为我听她自怨自艾或者自我陶醉，有时也倾听她的沉默。因为她是我的玫瑰。\n沙漠之所以美丽，是因为在它的某个地方，藏着一口水井……\n重要的东西，是肉眼看不见的。这就好比那朵花儿。如果你爱上了一颗星星上的一朵花儿，夜晚你看着天空，就会觉得很美。所有的星星都像开满了花儿。\n夜里，你会抬头看星星。我那颗实在太小了，我都没法儿指给你看它在哪里。这样更好。我的星星，对你来说就是满天繁星中的一颗。所以，你会爱看这满天的星星……所有的星星都会是你的朋友。\n\n\n\n\n\n","categories":["阅读"],"tags":["阅读"]},{"title":"阅读 2026-02-26 《务虚笔记》-史铁生","url":"/7657455a5a30/%E9%98%85%E8%AF%BB-2026-02-26/","content":"\n  span {\n    cursor: pointer;\n    text-decoration: underline;\n  }\n\n\n\n一切被意识到的生活都是被意识改造过的，它们只是作为意义的载体才是真实的，而意义乃是现在的赋予。那么我们真实地占有现在吗？如果占有，是多久？“现在”你说是多久？一分钟？一秒钟？百分之一秒抑或万分之一秒？这样下去“现在”岂不是要趋于零了？也许，“现在”仅仅是我们意识到一种意义所必要的时间？但是一切被意识到的生活一旦被意识到就已成为过去，意义一旦成为意义便已走向未来。现在是趋于零的，现在若不与过去和未来连接便是死灭，便是虚空。那么未来呢？未来是真实的吗？噢是的，未来的真实在于它是未来，在于它的不曾到来，在于它仅仅是一片梦想。过去在走向未来，意义追随着梦想，在意义与梦想之间，在它们的重叠之处就是现在。在它们的重叠之处，我们在途中，我们在现在。\n\n\n我是我的印象的一部分而我的全部印象才是我\n\n\n很可能，这颗星球上的一切梦想，都是由于生命本身的密码……那密码是什么呢？残疾？还是爱情？是残疾也是爱情。\n\n    \n      body.scroll-lock {\n        overflow: hidden;\n      }\n      \n      .custom-drawer-button {\n        background-color: transparent;\n        border: none;\n        cursor: pointer;\n        font-size: 16px;\n        color: #28a9ffff;\n      }\n      \n      .custom-drawer {\n        display: none;\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.4);\n        z-index: 999;\n      }\n      \n      .custom-drawer.open {\n        display: block;\n      }\n      \n      .drawer-content {\n        position: fixed;\n        top: 0;\n        height: 100%;\n        background-color: white;\n        z-index: 1000;\n        padding: 20px;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);\n      }\n      \n      .drawer-close {\n        position: absolute;\n        top: 10px;\n        right: 10px;\n        background: none;\n        border: none;\n        font-size: 20px;\n        cursor: pointer;\n        color: #333;\n      }\n      \n      .drawer-content {\n        animation-duration: 0.3s;\n      }\n      \n      .drawer-content-inner{\n        height: 100%;\n        overflow-y: auto;\n        margin-top: 20px;\n        margin-right: -20px;\n        padding-right: 20px;\n        white-space: pre-wrap;\n        word-break: break-word;\n      }\n    \n    \n    \n      查看原文\n    \n\n    \n      function openDrawer() {\n        const drawer = document.getElementById('custom-drawer');\n        const drawerContent = drawer.querySelector('.drawer-content');\n        drawer.classList.add('open');\n        drawerContent.classList.remove('animate__fadeOutRight');\n        drawerContent.classList.add('animate__fadeInRight');\n        document.body.classList.add('scroll-lock');\n      }\n      \n      function closeDrawer() {\n        const drawer = document.getElementById('custom-drawer');\n        const drawerContent = drawer.querySelector('.drawer-content');\n        drawerContent.classList.remove('animate__fadeInRight');\n        drawerContent.classList.add('animate__fadeOutRight');\n      }\n      \n      window.onload = function() {\n        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        const drawerWidth = isMobile ? '80%' : '450px';\n        \n        const drawer = document.createElement('div');\n        drawer.id = 'custom-drawer';\n        drawer.classList.add('custom-drawer');\n        \n        const drawerContent = document.createElement('div');\n        drawerContent.classList.add('drawer-content', 'animate__animated');\n        \n        drawerContent.style.width = drawerWidth;\n        if ('right' === 'left') {\n          drawerContent.style.left = 0\n        } else {\n          drawerContent.style.right = 0\n        }\n        \n        drawerContent.addEventListener('animationend', function(event) {\n          if (event.animationName.includes('fadeOut')) {\n            drawer.classList.remove('open');\n            document.body.classList.remove('scroll-lock'); \n          }\n        });\n        \n        const closeButton = document.createElement('button');\n        closeButton.classList.add('drawer-close');\n        closeButton.innerHTML = '&times;';\n        closeButton.onclick = closeDrawer;\n        \n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('drawer-content-inner');\n        contentDiv.innerHTML = `那是个不同寻常的夏天。整个城市都像是处在热恋中，人们都不待在家里，条条大街上都是人的河流，在宽阔的地带聚成人的海洋……似乎是那阵阵热风，忽然掀动了人们悠久的梦想……C摇着轮椅在街上走，被人流裹挟着，冲卷着……喧嚣的人声仿佛是那辽阔的阳光和风中固有的音讯。C停下轮椅，坐在河边，心里想：也许梦想都是相似的路途，都是同一种神秘的指使……\n什么？在这写作之夜我问他：你说什么？什么神秘的指使？\n他埋头想了一会儿，然后我听见他在那河边说：生命本身的密码。很可能，这颗星球上的一切梦想，都是由于生命本身的密码……\n他痴迷的眼睛里是涌动的人群，继而是深阔的蓝天。他仰头冥望。我知道，他必是刹那间又看遍了自己的四十年。\n我轻声问他：那密码是什么呢？\nC久久不语。\n我轻声问他：残疾？还是爱情？\n我等着，直到我看见，他的目光从深阔的蓝天上降落，涌动的人群重又在他眼睛里升起，他才点点头——声音传进我的写作之夜：是呀，是残疾也是爱情。`;\n        \n        drawerContent.appendChild(closeButton);\n        drawerContent.appendChild(contentDiv);\n        drawer.appendChild(drawerContent);\n        \n        document.body.appendChild(drawer);\n        \n        window.addEventListener('resize', function() {\n          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n          const drawerWidth = isMobile ? '80%' : '450px';\n          drawerContent.style.width = drawerWidth;\n        });\n\n        drawer.addEventListener('click', function(event) {\n          if (event.target === drawer) {\n            closeDrawer();\n          }\n        });\n      }\n    \n  \n\n时间是个怪物，最令人不解的谜。\n\n\n死，怎么可以把一个人那么多那么多不容轻蔑的痛苦、愿望、期盼，也许还有幸福，就那么迅速、简单、轻而易举地统统化为零了呢？\n\n\n在这世界上我只爱你，要是我有力量再爱一回，我还是要选择你。\n\n\n任何形式都是要说话的，都是一种公开的或悄悄的告白，一种形式不是表达一种真意，就是变卖一种真意。你可以闭目塞听，但你无法关闭心灵的耳目，谁也逃不脱这形式的告白。\n\n    \n      body.scroll-lock {\n        overflow: hidden;\n      }\n      \n      .custom-drawer-button {\n        background-color: transparent;\n        border: none;\n        cursor: pointer;\n        font-size: 16px;\n        color: #28a9ffff;\n      }\n      \n      .custom-drawer {\n        display: none;\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.4);\n        z-index: 999;\n      }\n      \n      .custom-drawer.open {\n        display: block;\n      }\n      \n      .drawer-content {\n        position: fixed;\n        top: 0;\n        height: 100%;\n        background-color: white;\n        z-index: 1000;\n        padding: 20px;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);\n      }\n      \n      .drawer-close {\n        position: absolute;\n        top: 10px;\n        right: 10px;\n        background: none;\n        border: none;\n        font-size: 20px;\n        cursor: pointer;\n        color: #333;\n      }\n      \n      .drawer-content {\n        animation-duration: 0.3s;\n      }\n      \n      .drawer-content-inner{\n        height: 100%;\n        overflow-y: auto;\n        margin-top: 20px;\n        margin-right: -20px;\n        padding-right: 20px;\n        white-space: pre-wrap;\n        word-break: break-word;\n      }\n    \n    \n    \n      查看原文\n    \n\n    \n      function openDrawer() {\n        const drawer = document.getElementById('custom-drawer');\n        const drawerContent = drawer.querySelector('.drawer-content');\n        drawer.classList.add('open');\n        drawerContent.classList.remove('animate__fadeOutRight');\n        drawerContent.classList.add('animate__fadeInRight');\n        document.body.classList.add('scroll-lock');\n      }\n      \n      function closeDrawer() {\n        const drawer = document.getElementById('custom-drawer');\n        const drawerContent = drawer.querySelector('.drawer-content');\n        drawerContent.classList.remove('animate__fadeInRight');\n        drawerContent.classList.add('animate__fadeOutRight');\n      }\n      \n      window.onload = function() {\n        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        const drawerWidth = isMobile ? '80%' : '450px';\n        \n        const drawer = document.createElement('div');\n        drawer.id = 'custom-drawer';\n        drawer.classList.add('custom-drawer');\n        \n        const drawerContent = document.createElement('div');\n        drawerContent.classList.add('drawer-content', 'animate__animated');\n        \n        drawerContent.style.width = drawerWidth;\n        if ('right' === 'left') {\n          drawerContent.style.left = 0\n        } else {\n          drawerContent.style.right = 0\n        }\n        \n        drawerContent.addEventListener('animationend', function(event) {\n          if (event.animationName.includes('fadeOut')) {\n            drawer.classList.remove('open');\n            document.body.classList.remove('scroll-lock'); \n          }\n        });\n        \n        const closeButton = document.createElement('button');\n        closeButton.classList.add('drawer-close');\n        closeButton.innerHTML = '&times;';\n        closeButton.onclick = closeDrawer;\n        \n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('drawer-content-inner');\n        contentDiv.innerHTML = `就好比说，你绝不能在婚礼上采用葬礼的仪式，也绝不能在葬礼上播放婚礼进行曲。这时候，形式，是至关重要的。但她自己也想不通为什么这样看重形式，这样苛刻地对待一种形式。很可能是因为：比如一个骗子，别人不知道他在骗人，但他自己不可能不知道他是在干什么，因而他无法再用同样的方式骗自己。关键就在这儿——任何形式都是要说话的，都是一种公开的或悄悄的告白，一种形式不是表达一种真意，就是变卖一种真意。你可以闭目塞听，但你无法关闭心灵的耳目，谁也逃不脱这形式的告白。比如性，那赤裸的相见，不是赤裸地表白爱的真诚、坦荡，就是赤裸地宣布对爱的轻蔑和抹杀。`;\n        \n        drawerContent.appendChild(closeButton);\n        drawerContent.appendChild(contentDiv);\n        drawer.appendChild(drawerContent);\n        \n        document.body.appendChild(drawer);\n        \n        window.addEventListener('resize', function() {\n          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n          const drawerWidth = isMobile ? '80%' : '450px';\n          drawerContent.style.width = drawerWidth;\n        });\n\n        drawer.addEventListener('click', function(event) {\n          if (event.target === drawer) {\n            closeDrawer();\n          }\n        });\n      }\n    \n  \n\n那无以计量的虚无结束于什么？结束于“我”。我醒来，我睁开眼睛，虚无顷刻消散，我看见世界。虚无从世界为我准备的那个网结上开始消散，世界从虚无由之消散的那个网结上开始拓展，拓展出我的盼望，或者随着我的盼望拓展……\n\n\n总是有这样的人，在残酷的春天我常感觉到他们的存在，无论是在繁华还是偏僻的地方这世界上处处分布着他们荒凉的祈盼。\n\n\n\n\n\n","categories":["阅读"],"tags":["阅读"]},{"title":"阅读 2026-02-27 《务虚笔记》-史铁生","url":"/08642825cf87/%E9%98%85%E8%AF%BB-2026-02-27/","content":"\n不管什么时候，我们可能丢失和我们真正要寻找的都是——爱情对爱情来说，什么年龄都合适\n\n    \n      body.scroll-lock {\n        overflow: hidden;\n      }\n      \n      .custom-drawer-button {\n        background-color: transparent;\n        border: none;\n        cursor: pointer;\n        font-size: 16px;\n        color: #28a9ffff;\n      }\n      \n      .custom-drawer {\n        display: none;\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.4);\n        z-index: 999;\n      }\n      \n      .custom-drawer.open {\n        display: block;\n      }\n      \n      .drawer-content {\n        position: fixed;\n        top: 0;\n        height: 100%;\n        background-color: white;\n        z-index: 1000;\n        padding: 20px;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);\n      }\n      \n      .drawer-close {\n        position: absolute;\n        top: 10px;\n        right: 10px;\n        background: none;\n        border: none;\n        font-size: 20px;\n        cursor: pointer;\n        color: #333;\n      }\n      \n      .drawer-content {\n        animation-duration: 0.3s;\n      }\n      \n      .drawer-content-inner{\n        height: 100%;\n        overflow-y: auto;\n        margin-top: 20px;\n        margin-right: -20px;\n        padding-right: 20px;\n        white-space: pre-wrap;\n        word-break: break-word;\n      }\n    \n    \n    \n      查看原文\n    \n\n    \n      function openDrawer() {\n        const drawer = document.getElementById('custom-drawer');\n        const drawerContent = drawer.querySelector('.drawer-content');\n        drawer.classList.add('open');\n        drawerContent.classList.remove('animate__fadeOutRight');\n        drawerContent.classList.add('animate__fadeInRight');\n        document.body.classList.add('scroll-lock');\n      }\n      \n      function closeDrawer() {\n        const drawer = document.getElementById('custom-drawer');\n        const drawerContent = drawer.querySelector('.drawer-content');\n        drawerContent.classList.remove('animate__fadeInRight');\n        drawerContent.classList.add('animate__fadeOutRight');\n      }\n      \n      window.onload = function() {\n        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        const drawerWidth = isMobile ? '80%' : '450px';\n        \n        const drawer = document.createElement('div');\n        drawer.id = 'custom-drawer';\n        drawer.classList.add('custom-drawer');\n        \n        const drawerContent = document.createElement('div');\n        drawerContent.classList.add('drawer-content', 'animate__animated');\n        \n        drawerContent.style.width = drawerWidth;\n        if ('right' === 'left') {\n          drawerContent.style.left = 0\n        } else {\n          drawerContent.style.right = 0\n        }\n        \n        drawerContent.addEventListener('animationend', function(event) {\n          if (event.animationName.includes('fadeOut')) {\n            drawer.classList.remove('open');\n            document.body.classList.remove('scroll-lock'); \n          }\n        });\n        \n        const closeButton = document.createElement('button');\n        closeButton.classList.add('drawer-close');\n        closeButton.innerHTML = '&times;';\n        closeButton.onclick = closeDrawer;\n        \n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('drawer-content-inner');\n        contentDiv.innerHTML = `写作之夜，N所以是女导演N，所以在我的印象中有了这一种职业，是因为在那个早来的夏天，传说她忽发奇想，借来一部摄影机，请来一对青年演员，在人潮如涌的大街上，拍摄了三本胶片。她相信，无论过去还是将来，任何导演都不可能再现如此浩大壮观的场面。女导演N所要拍摄的情节非常简单，只是男女主人公在万头攒动的人群中忧心如焚地互相寻找。她给两个演员的提示也很简单：“第一，男女主人公正在初恋的狂热之中。第二，他们不小心在这动荡的人群中互相丢失了。”演员问：“接下去呢？”N摇摇头，说：“不知道。”“剧本在哪儿？”“没有。没有剧本，甚至连故事都还没有。现在除了这对恋人在互相寻找，什么都还来不及想。”“那你凭什么相信，这情节，在你将来的故事里一定用得上呢？”N说：“因为我相信不管什么时候，我们可能丢失和我们真正要寻找的都是——爱情！”N说：“就是现在，我也敢说在我们视野所及的范围里，至少有几千对恋人正在互相寻找，正在为爱情祈祷上苍。”N站在一辆平板三轮车上，把定摄影机，对准那两个青年演员，在人的海洋中缓缓行进，跟拍这一对焦灼地相互寻找着的恋人。一群记者追着她问：“你认为，你的这部片子什么时候能够公映呢？”N回答：“这不是问题。”记者问她：“你是否想过，你一定能把它拍完吗？”N回答：“我早晚会把它拍完。”记者问：“如果那时这两个演员已经不合适了呢？比如说，他们已经老了呢？”N思忖片刻，说：“对爱情来说，什么年龄都合适。只要我那时还活着，我还是要把他们请来，我将拍摄两个白发苍苍的老人互相亲吻着回忆往昔，互相亲吻着，回忆他们几十年中乃至一生一世历尽艰辛的寻找。”人群中有个声音问：“喂，女导演，光是亲吻吗？在您的爱情故事里打不打算出现性场面呢？”人群中于是有些窃笑。女导演回答：“是的先生，您提醒了我，那动人的爱情当然需要有一个无遮无拦的美丽仪式，不可或缺！”笑声于是淹没在刹那的肃静中，和由肃静中突然爆发的掌声里。记者接着问：“那么从青年到老年，这间隔您打算怎么拍呢？这期间的他们由谁来扮演？”N说：“由所有的人来扮演。”她把摄影机缓缓地摇了三百六十度，说：“由现在一直到那时的，所有的恋人们，来补充！”`;\n        \n        drawerContent.appendChild(closeButton);\n        drawerContent.appendChild(contentDiv);\n        drawer.appendChild(drawerContent);\n        \n        document.body.appendChild(drawer);\n        \n        window.addEventListener('resize', function() {\n          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n          const drawerWidth = isMobile ? '80%' : '450px';\n          drawerContent.style.width = drawerWidth;\n        });\n\n        drawer.addEventListener('click', function(event) {\n          if (event.target === drawer) {\n            closeDrawer();\n          }\n        });\n      }\n    \n  \n\n我等你，直到垂暮之年&#x2F;野草有了&#x2F;一百代子孙，那条长椅上仍然&#x2F;空留着一个位置&#x2F;……\n\n\n如果爱是真的爱就不可能错，如果那爱是假的那根本就不是爱……\n\n\n梦是自己做的，并且仅仅是做给自己的，与他人无关，就像诗其实仅仅是写给自己的没道理发表或朗诵一样。如果上帝并不允许一个人把他的梦统统忘得干净，那么最好让梦停留在最美丽的位置，在那儿画一个句号，或是一行删节号。所谓最美丽的位置，并不一定是指最快乐的位置，最痛苦的位置也行，最忧伤最煎熬的位置也可以。\n\n\n一个幸福的位置，其实就因为它是一个美丽的位置。美丽的位置？对了，那必不能是一个从赤诚相见退回到彬彬有礼的位置。一个美丽的位置？对了，那必不能是一个心血枯焦却被轻描淡写的位置。\n\n\n也许从来就有这样一个秘诀：咒语由被施咒的人自己说出来，就是解除咒语的方法。\n\n\n“一个人总有一天会发现自己是孤零零的一个人。”\n\n\n\n\n\n","categories":["阅读"],"tags":["阅读"]},{"title":"阅读 2026-03-01 《务虚笔记》-史铁生","url":"/611890eac8fc/%E9%98%85%E8%AF%BB-2026-03-01/","content":"\n表达自己的软弱，即是表达对他人的需要。爱，就是对他人的依赖，对自由和平安的依赖。所以……所以……所以什么？所以那是危险的……危险的？你不知道他人会不会响应。是响应还是蔑视，你没有把握。\n\n\n宽慰不排除爱也不排除恨甚至不排除“纵使相逢应不识”，而只排除平庸，只排除不失礼数地把你标明在一个客人的位置上，把你推开在一个得当的距离之外——对了：朋友。这位置，这距离，是一条魔谷，是一道鬼墙，是一个丑恶凶残食人魂魄的老妖，它能点金成石、化血为水，把你舍命的珍藏“刷拉”一下翻转成一场漫不经心的玩笑。\n\n\n如果这舞台的灯光照亮着你，如果我们相距得足够近，你的影像映入我的眼帘，这就叫做：现实。如果这舞台的灯光照亮过你，当我回来你的影像已经飘离，如果你的影像已经飘进茫茫宇宙，这就叫做：过去。如果我已经回来，如果你已经不在，但我的意识超越光速我以心灵的目光追踪你飘离的影像，这就是：眺望。如果现实已成过去，如果过去永远现实，一个伤痕累累的欲念在没有地点的时间中或在抹杀了时间的地点上，如果追上了一个飘离的影像那就是：梦。那就是梦。\n\n\n“忘记”这两个字能使一切珍贵的东西消灭，仿佛不管什么原本都一钱不值。\n\n\n一个拿死说来说去的人，以我的经验看，其实并不是真的想死，而是……而是还在……还在渴望爱……\n\n    \n      body.scroll-lock {\n        overflow: hidden;\n      }\n      \n      .custom-drawer-button {\n        background-color: transparent;\n        border: none;\n        cursor: pointer;\n        font-size: 16px;\n        color: #28a9ffff;\n      }\n      \n      .custom-drawer {\n        display: none;\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.4);\n        z-index: 999;\n      }\n      \n      .custom-drawer.open {\n        display: block;\n      }\n      \n      .drawer-content {\n        position: fixed;\n        top: 0;\n        height: 100%;\n        background-color: white;\n        z-index: 1000;\n        padding: 20px;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);\n      }\n      \n      .drawer-close {\n        position: absolute;\n        top: 10px;\n        right: 10px;\n        background: none;\n        border: none;\n        font-size: 20px;\n        cursor: pointer;\n        color: #333;\n      }\n      \n      .drawer-content {\n        animation-duration: 0.3s;\n      }\n      \n      .drawer-content-inner{\n        height: 100%;\n        overflow-y: auto;\n        margin-top: 20px;\n        margin-right: -20px;\n        padding-right: 20px;\n        white-space: pre-wrap;\n        word-break: break-word;\n      }\n    \n    \n    \n      查看原文\n    \n\n    \n      function openDrawer() {\n        const drawer = document.getElementById('custom-drawer');\n        const drawerContent = drawer.querySelector('.drawer-content');\n        drawer.classList.add('open');\n        drawerContent.classList.remove('animate__fadeOutRight');\n        drawerContent.classList.add('animate__fadeInRight');\n        document.body.classList.add('scroll-lock');\n      }\n      \n      function closeDrawer() {\n        const drawer = document.getElementById('custom-drawer');\n        const drawerContent = drawer.querySelector('.drawer-content');\n        drawerContent.classList.remove('animate__fadeInRight');\n        drawerContent.classList.add('animate__fadeOutRight');\n      }\n      \n      window.onload = function() {\n        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        const drawerWidth = isMobile ? '80%' : '450px';\n        \n        const drawer = document.createElement('div');\n        drawer.id = 'custom-drawer';\n        drawer.classList.add('custom-drawer');\n        \n        const drawerContent = document.createElement('div');\n        drawerContent.classList.add('drawer-content', 'animate__animated');\n        \n        drawerContent.style.width = drawerWidth;\n        if ('right' === 'left') {\n          drawerContent.style.left = 0\n        } else {\n          drawerContent.style.right = 0\n        }\n        \n        drawerContent.addEventListener('animationend', function(event) {\n          if (event.animationName.includes('fadeOut')) {\n            drawer.classList.remove('open');\n            document.body.classList.remove('scroll-lock'); \n          }\n        });\n        \n        const closeButton = document.createElement('button');\n        closeButton.classList.add('drawer-close');\n        closeButton.innerHTML = '&times;';\n        closeButton.onclick = closeDrawer;\n        \n        const contentDiv = document.createElement('div');\n        contentDiv.classList.add('drawer-content-inner');\n        contentDiv.innerHTML = `“F医生，你没想过死吗？”\n“想过，想不大懂。”\n“就像睡着了，连梦都没有，什么都没有了，毫无知觉。”\n“但那是你醒后的回顾，是你又有了知觉时的发现。而且那时你还会发现：一切都存在，毫无改变，那段毫无知觉的时间等于零，那圆圆的零早已滚得无影无踪了，等于从未存在。”\n“所以不要再醒来。像睡着了一样，只是不要再醒来，那就是死。多么简单哪F医生，那就是死，就什么都没有了。”\n“你是说绝对的虚无，是吗？”\n“什么什么都没有了，对，绝对的虚无，一切都没有了。F医生，那是多么轻松啊！”\n“首先，什么什么都没有了也就没有轻松……”\n“随便，那无所谓，我不在乎。”\n“其次，根本就没有那回事。绝对的虚无根本不可能有。”\n“怎么不可能有？”\n“如果有，那又怎么会是绝对的无呢？”\n病房之夜，间断地传来病人凄厉的呻吟。寂静和呻吟交替。呻吟在寂静与寂静之间显得鲜明，寂静在呻吟与呻吟之间显得悠久。\n“有，才是绝对的。依我想，没有绝对的虚无，只有绝对的存在。”\n“F医生，那……死是什么？”\n“不知道。也许是又一次开始，另一种开始。也许恰恰是醒来，从一种欲望中醒来，醒到另一种欲望里去。”\n“为什么一定是欲望？”\n“存在就是运动，运动就有方向，方向就是欲望。”\n“啊……我可不想再要什么欲望，不想再有任何欲望。”\n“你想有，或者你想无，那都是欲望。”\n“我不如是块石头。”\n“石头早就在那儿了，你劳驾低头看看这地面。”\n“我是说我，我最好是一块石头。”\n“‘我’总也是不了石头。石头不会说‘我’，意识到‘我’的都不是石头而是欲望。石头只能是‘它’。”\n“我会变成一把灰的，这你不信吗？”\n“烧成一把灰，再凝成一块石头，这我信，你早晚会这样的。但是，‘我’不会。”\n“你说什么，你不会死？F医生你清醒吗？”\n“我并没说F医生，我说的是‘我’，我是说欲望。欲望是不会死的，而欲望的名字永远叫做‘我’——在英语里是‘I’，在一切语言里都有一个相应的字，发音不同但表达相同的意思。这欲望如果不愧是欲望，就难免会失恋，这失恋的痛苦就只有‘我’知道。至于‘我’偶然有怎样一个人间的姓名，那不重要，是F，是L，是C，是O，是N，那都一样，都不过是以‘我’的角度感受那痛苦，都不过是在‘我’的位置上经受折磨。”\n“F医生，您不必弄这套玄虚来劝我活。”\n“那你就死吧，看看会怎么样。”\n“你也不用这么激我。一个想死的人什么都不在乎。”\n“这我信，而且一个真正想死的人也不在乎死是什么，他死就是了，不会还这么絮絮叨叨声明自己多么想死，想摆脱欲望，想成为一块石头，一把灰，说不定还想成为一块美丽的云彩，一阵自由的风……”\n“你是说我并不想死，我是在这儿虚张声势？”\n“不是虚张声势，是摇尾乞怜。别生气，一个真正想死的人不会再计较别人说什么。一个拿死说来说去的人，以我的经验看，其实并不是真的想死，而是……”\n“而是什么？”\n“而是还在……还在渴望爱……”`;\n        \n        drawerContent.appendChild(closeButton);\n        drawerContent.appendChild(contentDiv);\n        drawer.appendChild(drawerContent);\n        \n        document.body.appendChild(drawer);\n        \n        window.addEventListener('resize', function() {\n          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n          const drawerWidth = isMobile ? '80%' : '450px';\n          drawerContent.style.width = drawerWidth;\n        });\n\n        drawer.addEventListener('click', function(event) {\n          if (event.target === drawer) {\n            closeDrawer();\n          }\n        });\n      }\n    \n  \n\n\n\n\n","categories":["阅读"],"tags":["阅读"]}]